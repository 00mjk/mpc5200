Bottom: a77117c089dfe05f2157a309e96d3a0ad845b267
Top:    f2bb2bbe9d6c2cb6556cf3420f6158fe13fc212a
Author: Jon Smirl <jonsmirl@gmail.com>
Date:   2008-11-04 17:16:40 -0500

Refresh of jds-lirc

---

diff --git a/drivers/input/ir/ir-gpt.c b/drivers/input/ir/ir-gpt.c
new file mode 100644
index 0000000..ab83d89
--- /dev/null
+++ b/drivers/input/ir/ir-gpt.c
@@ -0,0 +1,224 @@
+/*
+ * GPT timer based IR device
+ *
+ * Copyright (C) 2008 Jon Smirl <jonsmirl@gmail.com>
+ */
+
+#define DEBUG
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/interrupt.h>
+#include <linux/device.h>
+#include <linux/of_device.h>
+#include <linux/of_platform.h>
+#include <linux/input.h>
+#include <asm/io.h>
+#include <asm/mpc52xx.h>
+
+#define MAX_SAMPLES 200
+
+struct ir_gpt {
+	int irq;
+	struct mpc52xx_gpt __iomem *regs;
+	spinlock_t lock;
+	struct work_struct queue;
+	int head, tail, previous;
+	unsigned int samples[MAX_SAMPLES];
+	struct input_dev *input;
+};
+
+static void ir_event(struct work_struct *work)
+{
+	unsigned long flags;
+	int delta, count;
+	unsigned int sample, wrap, bit;
+	struct ir_gpt *ir_gpt = container_of(work, struct ir_gpt, queue);
+
+	while (1) {
+		spin_lock_irqsave(ir_gpt->lock, flags);
+		if (ir_gpt->tail == ir_gpt->head) {
+			spin_unlock_irqrestore(ir_gpt->lock, flags);
+			break;
+		}
+		sample = ir_gpt->samples[ir_gpt->tail];
+
+		ir_gpt->tail++;
+		if (ir_gpt->tail >= MAX_SAMPLES)
+			ir_gpt->tail = 0;
+
+		spin_unlock_irqrestore(ir_gpt->lock, flags);
+
+		count = sample >> 16;
+		wrap = (sample >> 12) & 7;
+		bit = (sample >> 8) & 1;
+
+		delta = count - ir_gpt->previous;
+		delta += wrap * 0x10000;
+
+		ir_gpt->previous = count;
+
+		input_ir_decode(ir_gpt->input, delta, bit);
+	}
+}
+
+/*
+ * Interrupt handlers
+ */
+static irqreturn_t dpeak_ir_irq(int irq, void *_ir)
+{
+	unsigned long flags;
+	unsigned int sample, next;
+	struct ir_gpt *ir_gpt = _ir;
+
+	sample = in_be32(&ir_gpt->regs->status);
+	out_be32(&ir_gpt->regs->status, 0xF);
+
+	spin_lock_irqsave(ir_gpt->lock, flags);
+	ir_gpt->samples[ir_gpt->head] = sample;
+	next = ir_gpt->head + 1;
+	ir_gpt->head = (next >= MAX_SAMPLES ? 0 : next);
+	spin_unlock_irqrestore(ir_gpt->lock, flags);
+
+	schedule_work(&ir_gpt->queue);
+
+	return IRQ_HANDLED;
+}
+
+
+/* ---------------------------------------------------------------------
+ * OF platform bus binding code:
+ * - Probe/remove operations
+ * - OF device match table
+ */
+static int __devinit ir_gpt_of_probe(struct of_device *op,
+				      const struct of_device_id *match)
+{
+	struct ir_gpt *ir_gpt;
+	struct resource res;
+	int ret, rc;
+
+	dev_dbg(&op->dev, "ir_gpt_of_probe\n");
+
+	/* Allocate and initialize the driver private data */
+	ir_gpt = kzalloc(sizeof *ir_gpt, GFP_KERNEL);
+	if (!ir_gpt)
+		return -ENOMEM;
+
+	ir_gpt->input = input_allocate_device();
+	if (!ir_gpt->input) {
+		ret = -ENOMEM;
+		goto free_mem;
+	}
+	ret = input_ir_create(ir_gpt->input, ir_gpt, NULL);
+	if (ret)
+		goto free_input;
+
+	ir_gpt->input->id.bustype = BUS_HOST;
+	ir_gpt->input->name = "GPT IR Receiver";
+
+	ir_gpt->input->irbit[0] |= BIT_MASK(IR_CAP_RECEIVE_36K);
+	ir_gpt->input->irbit[0] |= BIT_MASK(IR_CAP_RECEIVE_38K);
+	ir_gpt->input->irbit[0] |= BIT_MASK(IR_CAP_RECEIVE_40K);
+	ir_gpt->input->irbit[0] |= BIT_MASK(IR_CAP_RECEIVE_RAW);
+
+	ret = input_register_device(ir_gpt->input);
+	if (ret)
+		goto free_input;
+	ret = input_ir_register(ir_gpt->input);
+	if (ret)
+		goto free_input;
+
+	spin_lock_init(&ir_gpt->lock);
+	INIT_WORK (&ir_gpt->queue, ir_event);
+
+	/* Fetch the registers and IRQ of the GPT */
+	if (of_address_to_resource(op->node, 0, &res)) {
+		dev_err(&op->dev, "Missing reg property\n");
+		ret = -ENODEV;
+		goto free_input;
+	}
+	ir_gpt->regs = ioremap(res.start, 1 + res.end - res.start);
+	if (!ir_gpt->regs) {
+		dev_err(&op->dev, "Could not map registers\n");
+		ret = -ENODEV;
+		goto free_input;
+	}
+	ir_gpt->irq = irq_of_parse_and_map(op->node, 0);
+	if (ir_gpt->irq == NO_IRQ) {
+		ret = -ENODEV;
+		goto free_input;
+	}
+	dev_dbg(&op->dev, "ir_gpt_of_probe irq=%d\n", ir_gpt->irq);
+
+	rc = request_irq(ir_gpt->irq, &dpeak_ir_irq, IRQF_SHARED,
+			 "gpt-ir", ir_gpt);
+	dev_dbg(&op->dev, "ir_gpt_of_probe request irq rc=%d\n", rc);
+
+	/* set prescale to ? */
+	out_be32(&ir_gpt->regs->count, 0x00870000);
+
+	/* Select input capture, enable the counter, and interrupt */
+	out_be32(&ir_gpt->regs->mode, 0x0);
+	out_be32(&ir_gpt->regs->mode, 0x00000501);
+
+	/* Save what we've done so it can be found again later */
+	dev_set_drvdata(&op->dev, ir_gpt);
+
+	printk("GPT IR Receiver driver\n");
+
+	return 0;
+
+free_input:
+	input_ir_destroy(ir_gpt->input);
+	input_free_device(ir_gpt->input);
+free_mem:
+	kfree(ir_gpt);
+	return ret;
+}
+
+static int __devexit ir_gpt_of_remove(struct of_device *op)
+{
+	struct ir_gpt *ir_gpt = dev_get_drvdata(&op->dev);
+
+	dev_dbg(&op->dev, "ir_gpt_remove()\n");
+
+	input_ir_destroy(ir_gpt->input);
+	input_free_device(ir_gpt->input);
+	kfree(ir_gpt);
+	dev_set_drvdata(&op->dev, NULL);
+
+	return 0;
+}
+
+/* Match table for of_platform binding */
+static struct of_device_id ir_gpt_match[] __devinitdata = {
+	{ .compatible = "gpt-ir", },
+	{}
+};
+MODULE_DEVICE_TABLE(of, ir_gpt_match);
+
+static struct of_platform_driver ir_gpt_driver = {
+	.match_table = ir_gpt_match,
+	.probe = ir_gpt_of_probe,
+	.remove = __devexit_p(ir_gpt_of_remove),
+	.driver = {
+		.name = "ir-gpt",
+		.owner = THIS_MODULE,
+	},
+};
+
+/* ---------------------------------------------------------------------
+ * Module setup and teardown; simply register the of_platform driver
+ */
+static int __init ir_gpt_init(void)
+{
+	return of_register_platform_driver(&ir_gpt_driver);
+}
+module_init(ir_gpt_init);
+
+static void __exit ir_gpt_exit(void)
+{
+	of_unregister_platform_driver(&ir_gpt_driver);
+}
+module_exit(ir_gpt_exit);
diff --git a/drivers/input/ir/ir.h b/drivers/input/ir/ir.h
index 5bc55c3..fbc1345 100644
--- a/drivers/input/ir/ir.h
+++ b/drivers/input/ir/ir.h
@@ -42,8 +42,7 @@ struct ir_device {
 };
 
 extern struct configfs_subsystem input_ir_remotes;
-extern void input_ir_translate(struct input_dev *dev, int protocol, int device, int command);
-extern int input_ir_register(struct input_dev *dev);
+void input_ir_translate(struct input_dev *dev, int protocol, int device, int command);
 
 
 
diff --git a/include/linux/input.h b/include/linux/input.h
index b8a45aa..95e385f 100644
--- a/include/linux/input.h
+++ b/include/linux/input.h
@@ -1441,7 +1441,7 @@ int input_ff_create_memless(struct input_dev *dev, void *data,
 		int (*play_effect)(struct input_dev *, void *, struct ff_effect *));
 
 /**
- * struct ir_device - IR support functions
+ * IR support functions
  */
 
 typedef int (*send_func)(void *private, unsigned int *buffer, unsigned int count,
@@ -1452,6 +1452,7 @@ void input_ir_destroy(struct input_dev *dev);
 
 void input_ir_decode(struct input_dev *dev, unsigned int delta, unsigned int bit);
 int input_ir_send(struct input_dev *dev, struct ir_command *ir_command, struct file *file);
+int input_ir_register(struct input_dev *dev);
 
 #endif
 #endif

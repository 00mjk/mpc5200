Bottom: 31b28a64b7ef562f5c366804ddf4d552fbe08143
Top:    e5aac7e828d8f024d8d7bb311d0e982c27f3d594
Author: Jon Smirl <jonsmirl@gmail.com>
Date:   2009-04-10 22:51:07 -0400

AC97 driver for mpc5200


---

diff --git a/sound/soc/fsl/Kconfig b/sound/soc/fsl/Kconfig
index d480a73..16a1e28 100644
--- a/sound/soc/fsl/Kconfig
+++ b/sound/soc/fsl/Kconfig
@@ -38,12 +38,20 @@ config SND_SOC_MPC8610_HPCD
 
 config SND_SOC_MPC5200_I2S
 	tristate "Freescale MPC5200 PSC in I2S mode driver"
-	depends on PPC_MPC52xx && PPC_BESTCOMM
+	depends on SND_MPC52xx_SOC && PPC_BESTCOMM
 	select SND_SOC_OF_SIMPLE
 	select PPC_BESTCOMM_GEN_BD
 	help
 	  Say Y here to support the MPC5200 PSCs in I2S mode.
 
+config SND_SOC_MPC5200_AC97
+	tristate "Freescale MPC5200 PSC in AC97 mode driver"
+	depends on SND_MPC52xx_SOC && PPC_BESTCOMM
+	select SND_SOC_OF_SIMPLE
+	select PPC_BESTCOMM_GEN_BD
+	help
+	  Say Y here to support the MPC5200 PSCs in AC97 mode.
+
 config SND_MPC52xx_SOC_EFIKA
 	tristate "SoC AC97 Audio support for bbplan Efika and STAC9722"
 	depends on SND_MPC52xx_SOC && PPC_EFIKA
diff --git a/sound/soc/fsl/Makefile b/sound/soc/fsl/Makefile
index c3a49dc..70c44bf 100644
--- a/sound/soc/fsl/Makefile
+++ b/sound/soc/fsl/Makefile
@@ -13,6 +13,7 @@ obj-$(CONFIG_SND_SOC_MPC8610) += snd-soc-fsl-ssi.o snd-soc-fsl-dma.o
 # MPC5200 Platform Support
 obj-$(CONFIG_SND_MPC52xx_SOC) += mpc5200_dma.o
 obj-$(CONFIG_SND_SOC_MPC5200_I2S) += mpc5200_psc_i2s.o
+obj-$(CONFIG_SND_SOC_MPC5200_AC97) += mpc5200_psc_ac97.o
 
 # MPC5200 Machine Support
 snd_soc_dspeak01_fabric-objs := dspeak01_fabric.o
diff --git a/sound/soc/fsl/mpc5200_dma.c b/sound/soc/fsl/mpc5200_dma.c
new file mode 100644
index 0000000..a980cfe
--- /dev/null
+++ b/sound/soc/fsl/mpc5200_dma.c
@@ -0,0 +1,542 @@
+/*
+ * Freescale MPC5200 Audio DMA
+ *
+ * Copyright (C) 2008 Secret Lab Technologies Ltd.
+ */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/interrupt.h>
+#include <linux/device.h>
+#include <linux/delay.h>
+#include <linux/of_device.h>
+#include <linux/of_platform.h>
+#include <linux/dma-mapping.h>
+
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/initval.h>
+#include <sound/soc.h>
+#include <sound/soc-of-simple.h>
+
+#include <sysdev/bestcomm/bestcomm.h>
+#include <sysdev/bestcomm/gen_bd.h>
+#include <asm/time.h>
+#include <asm/mpc52xx.h>
+#include <asm/mpc52xx_psc.h>
+
+#include "mpc5200_dma.h"
+
+MODULE_AUTHOR("Grant Likely <grant.likely@secretlab.ca>");
+MODULE_DESCRIPTION("Freescale MPC5200 PSC in DMA mode ASoC Driver");
+MODULE_LICENSE("GPL");
+
+const struct snd_pcm_hardware mpc5200_pcm_hardware = {
+	.info = SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_MMAP_VALID |
+		SNDRV_PCM_INFO_INTERLEAVED | SNDRV_PCM_INFO_BLOCK_TRANSFER,
+	.formats = SNDRV_PCM_FMTBIT_S8 | SNDRV_PCM_FMTBIT_S16_BE |
+		   SNDRV_PCM_FMTBIT_S24_BE | SNDRV_PCM_FMTBIT_S32_BE,
+	.rate_min = 8000,
+	.rate_max = 48000,
+	.channels_min = 2,
+	.channels_max = 2,
+	.period_bytes_max	= 1024 * 1024,
+	.period_bytes_min	= 32,
+	.periods_min		= 2,
+	.periods_max		= 256,
+	.buffer_bytes_max	= 2 * 1024 * 1024,
+	.fifo_size		= 0,
+};
+
+/**
+ * psc_dma_stream - Data specific to a single stream (playback or capture)
+ * @active:		flag indicating if the stream is active
+ * @psc_dma:		pointer back to parent psc_dma data structure
+ * @bcom_task:		bestcomm task structure
+ * @irq:		irq number for bestcomm task
+ * @period_start:	physical address of start of DMA region
+ * @period_end:		physical address of end of DMA region
+ * @period_next_pt:	physical address of next DMA buffer to enqueue
+ * @period_bytes:	size of DMA period in bytes
+ */
+struct psc_dma_stream {
+	int active;
+	struct psc_dma *psc_dma;
+	struct bcom_task *bcom_task;
+	int irq;
+	struct snd_pcm_substream *stream;
+	dma_addr_t period_start;
+	dma_addr_t period_end;
+	dma_addr_t period_next_pt;
+	dma_addr_t period_current_pt;
+	int period_bytes;
+};
+
+/**
+ * psc_dma - Private driver data
+ * @name: short name for this device ("PSC0", "PSC1", etc)
+ * @psc_regs: pointer to the PSC's registers
+ * @fifo_regs: pointer to the PSC's FIFO registers
+ * @irq: IRQ of this PSC
+ * @dev: struct device pointer
+ * @dai: the CPU DAI for this device
+ * @sicr: Base value used in serial interface control register; mode is ORed
+ *        with this value.
+ * @playback: Playback stream context data
+ * @capture: Capture stream context data
+ */
+struct psc_dma {
+	char name[32];
+	struct mpc52xx_psc __iomem *psc_regs;
+	struct mpc52xx_psc_fifo __iomem *fifo_regs;
+	unsigned int irq;
+	struct device *dev;
+	struct snd_soc_dai dai;
+	spinlock_t lock;
+	u32 sicr;
+	uint sysclk;
+
+	/* per-stream data */
+	struct psc_dma_stream playback;
+	struct psc_dma_stream capture;
+
+	/* Statistics */
+	struct {
+		int overrun_count;
+		int underrun_count;
+	} stats;
+};
+
+/*
+ * Interrupt handlers
+ */
+static irqreturn_t psc_dma_status_irq(int irq, void *_psc_dma)
+{
+	struct psc_dma *psc_dma = _psc_dma;
+	struct mpc52xx_psc __iomem *regs = psc_dma->psc_regs;
+	u16 isr;
+
+	isr = in_be16(&regs->mpc52xx_psc_isr);
+
+	/* Playback underrun error */
+	if (psc_dma->playback.active && (isr & MPC52xx_PSC_IMR_TXEMP))
+		psc_dma->stats.underrun_count++;
+
+	/* Capture overrun error */
+	if (psc_dma->capture.active && (isr & MPC52xx_PSC_IMR_ORERR))
+		psc_dma->stats.overrun_count++;
+
+	out_8(&regs->command, 4 << 4);	/* reset the error status */
+
+	return IRQ_HANDLED;
+}
+
+/**
+ * psc_dma_bcom_enqueue_next_buffer - Enqueue another audio buffer
+ * @s: pointer to stream private data structure
+ *
+ * Enqueues another audio period buffer into the bestcomm queue.
+ *
+ * Note: The routine must only be called when there is space available in
+ * the queue.  Otherwise the enqueue will fail and the audio ring buffer
+ * will get out of sync
+ */
+static void psc_dma_bcom_enqueue_next_buffer(struct psc_dma_stream *s)
+{
+	struct bcom_bd *bd;
+
+	/* Prepare and enqueue the next buffer descriptor */
+	bd = bcom_prepare_next_buffer(s->bcom_task);
+	bd->status = s->period_bytes;
+	bd->data[0] = s->period_next_pt;
+	bcom_submit_next_buffer(s->bcom_task, NULL);
+
+	/* Update for next period */
+	s->period_next_pt += s->period_bytes;
+	if (s->period_next_pt >= s->period_end)
+		s->period_next_pt = s->period_start;
+}
+
+/* Bestcomm DMA irq handler */
+static irqreturn_t psc_dma_bcom_irq(int irq, void *_psc_dma_stream)
+{
+	struct psc_dma_stream *s = _psc_dma_stream;
+
+	/* For each finished period, dequeue the completed period buffer
+	 * and enqueue a new one in it's place. */
+	while (bcom_buffer_done(s->bcom_task)) {
+		bcom_retrieve_buffer(s->bcom_task, NULL, NULL);
+		s->period_current_pt += s->period_bytes;
+		if (s->period_current_pt >= s->period_end)
+			s->period_current_pt = s->period_start;
+		psc_dma_bcom_enqueue_next_buffer(s);
+		bcom_enable(s->bcom_task);
+	}
+
+	/* If the stream is active, then also inform the PCM middle layer
+	 * of the period finished event. */
+	if (s->active)
+		snd_pcm_period_elapsed(s->stream);
+
+	return IRQ_HANDLED;
+}
+
+/**
+ * psc_dma_startup: create a new substream
+ *
+ * This is the first function called when a stream is opened.
+ *
+ * If this is the first stream open, then grab the IRQ and program most of
+ * the PSC registers.
+ */
+int mpc5200_dma_startup(struct snd_pcm_substream *substream,
+			   struct snd_soc_dai *dai)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct psc_dma *psc_dma = rtd->dai->cpu_dai->private_data;
+	int rc;
+
+	dev_dbg(psc_dma->dev, "psc_dma_startup(substream=%p)\n", substream);
+
+	if (!psc_dma->playback.active &&
+	    !psc_dma->capture.active) {
+		/* Setup the IRQs */
+		rc = request_irq(psc_dma->irq, &psc_dma_status_irq, IRQF_SHARED,
+				 "psc-dma-status", psc_dma);
+		rc |= request_irq(psc_dma->capture.irq,
+				  &psc_dma_bcom_irq, IRQF_SHARED,
+				  "psc-dma-capture", &psc_dma->capture);
+		rc |= request_irq(psc_dma->playback.irq,
+				  &psc_dma_bcom_irq, IRQF_SHARED,
+				  "psc-dma-playback", &psc_dma->playback);
+		if (rc) {
+			free_irq(psc_dma->irq, psc_dma);
+			free_irq(psc_dma->capture.irq,
+				 &psc_dma->capture);
+			free_irq(psc_dma->playback.irq,
+				 &psc_dma->playback);
+			return -ENODEV;
+		}
+	}
+
+	return 0;
+}
+
+int mpc5200_dma_hw_free(struct snd_pcm_substream *substream,
+			   struct snd_soc_dai *dai)
+{
+	snd_pcm_set_runtime_buffer(substream, NULL);
+	return 0;
+}
+
+/**
+ * psc_dma_trigger: start and stop the DMA transfer.
+ *
+ * This function is called by ALSA to start, stop, pause, and resume the DMA
+ * transfer of data.
+ */
+int mpc5200_dma_trigger(struct snd_pcm_substream *substream, int cmd,
+			   struct snd_soc_dai *dai)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct psc_dma *psc_dma = rtd->dai->cpu_dai->private_data;
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct psc_dma_stream *s;
+	struct mpc52xx_psc __iomem *regs = psc_dma->psc_regs;
+	u16 imr;
+	u8 psc_cmd;
+	unsigned long flags;
+
+	if (substream->pstr->stream == SNDRV_PCM_STREAM_CAPTURE)
+		s = &psc_dma->capture;
+	else
+		s = &psc_dma->playback;
+
+	dev_dbg(psc_dma->dev, "psc_dma_trigger(substream=%p, cmd=%i)"
+		" stream_id=%i\n",
+		substream, cmd, substream->pstr->stream);
+
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_START:
+		s->period_bytes = frames_to_bytes(runtime,
+						  runtime->period_size);
+		s->period_start = virt_to_phys(runtime->dma_area);
+		s->period_end = s->period_start +
+				(s->period_bytes * runtime->periods);
+		s->period_next_pt = s->period_start;
+		s->period_current_pt = s->period_start;
+		s->active = 1;
+
+		/* First; reset everything */
+		if (substream->pstr->stream == SNDRV_PCM_STREAM_CAPTURE) {
+			out_8(&regs->command, MPC52xx_PSC_RST_RX);
+			out_8(&regs->command, MPC52xx_PSC_RST_ERR_STAT);
+		} else {
+			out_8(&regs->command, MPC52xx_PSC_RST_TX);
+			out_8(&regs->command, MPC52xx_PSC_RST_ERR_STAT);
+		}
+
+		/* Next, fill up the bestcomm bd queue and enable DMA.
+		 * This will begin filling the PSC's fifo. */
+		if (substream->pstr->stream == SNDRV_PCM_STREAM_CAPTURE)
+			bcom_gen_bd_rx_reset(s->bcom_task);
+		else
+			bcom_gen_bd_tx_reset(s->bcom_task);
+		while (!bcom_queue_full(s->bcom_task))
+			psc_dma_bcom_enqueue_next_buffer(s);
+		bcom_enable(s->bcom_task);
+
+		/* Due to errata in the dma mode; need to line up enabling
+		 * the transmitter with a transition on the frame sync
+		 * line */
+
+		spin_lock_irqsave(&psc_dma->lock, flags);
+		/* first make sure it is low */
+		while ((in_8(&regs->ipcr_acr.ipcr) & 0x80) != 0)
+			;
+		/* then wait for the transition to high */
+		while ((in_8(&regs->ipcr_acr.ipcr) & 0x80) == 0)
+			;
+		/* Finally, enable the PSC.
+		 * Receiver must always be enabled; even when we only want
+		 * transmit.  (see 15.3.2.3 of MPC5200B User's Guide) */
+		psc_cmd = MPC52xx_PSC_RX_ENABLE;
+		if (substream->pstr->stream == SNDRV_PCM_STREAM_PLAYBACK)
+			psc_cmd |= MPC52xx_PSC_TX_ENABLE;
+		out_8(&regs->command, psc_cmd);
+		spin_unlock_irqrestore(&psc_dma->lock, flags);
+
+		break;
+
+	case SNDRV_PCM_TRIGGER_STOP:
+		/* Turn off the PSC */
+		s->active = 0;
+		if (substream->pstr->stream == SNDRV_PCM_STREAM_CAPTURE) {
+			if (!psc_dma->playback.active) {
+				out_8(&regs->command, 2 << 4);	/* reset rx */
+				out_8(&regs->command, 3 << 4);	/* reset tx */
+				out_8(&regs->command, 4 << 4);	/* reset err */
+			}
+		} else {
+			out_8(&regs->command, 3 << 4);	/* reset tx */
+			out_8(&regs->command, 4 << 4);	/* reset err */
+			if (!psc_dma->capture.active)
+				out_8(&regs->command, 2 << 4);	/* reset rx */
+		}
+
+		bcom_disable(s->bcom_task);
+		while (!bcom_queue_empty(s->bcom_task))
+			bcom_retrieve_buffer(s->bcom_task, NULL, NULL);
+
+		break;
+
+	default:
+		dev_dbg(psc_dma->dev, "invalid command\n");
+		return -EINVAL;
+	}
+
+	/* Update interrupt enable settings */
+	imr = 0;
+	if (psc_dma->playback.active)
+		imr |= MPC52xx_PSC_IMR_TXEMP;
+	if (psc_dma->capture.active)
+		imr |= MPC52xx_PSC_IMR_ORERR;
+	out_be16(&regs->isr_imr.imr, imr);
+
+	return 0;
+}
+
+/**
+ * psc_dma_shutdown: shutdown the data transfer on a stream
+ *
+ * Shutdown the PSC if there are no other substreams open.
+ */
+void mpc5200_dma_shutdown(struct snd_pcm_substream *substream,
+			     struct snd_soc_dai *dai)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct psc_dma *psc_dma = rtd->dai->cpu_dai->private_data;
+
+	dev_dbg(psc_dma->dev, "psc_dma_shutdown(substream=%p)\n", substream);
+
+	/*
+	 * If this is the last active substream, disable the PSC and release
+	 * the IRQ.
+	 */
+	if (!psc_dma->playback.active &&
+	    !psc_dma->capture.active) {
+
+		/* Disable all interrupts and reset the PSC */
+		out_be16(&psc_dma->psc_regs->isr_imr.imr, 0);
+		out_8(&psc_dma->psc_regs->command, 3 << 4); /* reset tx */
+		out_8(&psc_dma->psc_regs->command, 2 << 4); /* reset rx */
+		out_8(&psc_dma->psc_regs->command, 1 << 4); /* reset mode */
+		out_8(&psc_dma->psc_regs->command, 4 << 4); /* reset error */
+
+		/* Release irqs */
+		free_irq(psc_dma->irq, psc_dma);
+		free_irq(psc_dma->capture.irq, &psc_dma->capture);
+		free_irq(psc_dma->playback.irq, &psc_dma->playback);
+	}
+}
+
+
+/* ---------------------------------------------------------------------
+ * ALSA SoC Bindings
+ *
+ * - Digital Audio Interface (DAI) template
+ * - create/destroy dai hooks
+ */
+
+
+/* ---------------------------------------------------------------------
+ * The PSC DMA 'ASoC platform' driver
+ *
+ * Can be referenced by an 'ASoC machine' driver
+ * This driver only deals with the audio bus; it doesn't have any
+ * interaction with the attached codec
+ */
+
+static const struct snd_pcm_hardware psc_dma_pcm_hardware = {
+	.info = SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_MMAP_VALID |
+		SNDRV_PCM_INFO_INTERLEAVED | SNDRV_PCM_INFO_BLOCK_TRANSFER,
+	.formats = SNDRV_PCM_FMTBIT_S8 | SNDRV_PCM_FMTBIT_S16_BE |
+		   SNDRV_PCM_FMTBIT_S24_BE | SNDRV_PCM_FMTBIT_S32_BE,
+	.rate_min = 8000,
+	.rate_max = 48000,
+	.channels_min = 2,
+	.channels_max = 2,
+	.period_bytes_max	= 1024 * 1024,
+	.period_bytes_min	= 32,
+	.periods_min		= 2,
+	.periods_max		= 256,
+	.buffer_bytes_max	= 2 * 1024 * 1024,
+	.fifo_size		= 0,
+};
+
+static int psc_dma_pcm_open(struct snd_pcm_substream *substream)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct psc_dma *psc_dma = rtd->dai->cpu_dai->private_data;
+	struct psc_dma_stream *s;
+
+	dev_dbg(psc_dma->dev, "psc_dma_pcm_open(substream=%p)\n", substream);
+
+	if (substream->pstr->stream == SNDRV_PCM_STREAM_CAPTURE)
+		s = &psc_dma->capture;
+	else
+		s = &psc_dma->playback;
+
+	snd_soc_set_runtime_hwparams(substream, &psc_dma_pcm_hardware);
+
+	s->stream = substream;
+	return 0;
+}
+
+static int psc_dma_pcm_close(struct snd_pcm_substream *substream)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct psc_dma *psc_dma = rtd->dai->cpu_dai->private_data;
+	struct psc_dma_stream *s;
+
+	dev_dbg(psc_dma->dev, "psc_dma_pcm_close(substream=%p)\n", substream);
+
+	if (substream->pstr->stream == SNDRV_PCM_STREAM_CAPTURE)
+		s = &psc_dma->capture;
+	else
+		s = &psc_dma->playback;
+
+	s->stream = NULL;
+	return 0;
+}
+
+static snd_pcm_uframes_t
+psc_dma_pcm_pointer(struct snd_pcm_substream *substream)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct psc_dma *psc_dma = rtd->dai->cpu_dai->private_data;
+	struct psc_dma_stream *s;
+	dma_addr_t count;
+
+	if (substream->pstr->stream == SNDRV_PCM_STREAM_CAPTURE)
+		s = &psc_dma->capture;
+	else
+		s = &psc_dma->playback;
+
+	count = s->period_current_pt - s->period_start;
+
+	return bytes_to_frames(substream->runtime, count);
+}
+
+static struct snd_pcm_ops psc_dma_pcm_ops = {
+	.open		= psc_dma_pcm_open,
+	.close		= psc_dma_pcm_close,
+	.ioctl		= snd_pcm_lib_ioctl,
+	.pointer	= psc_dma_pcm_pointer,
+};
+
+static u64 psc_dma_pcm_dmamask = 0xffffffff;
+static int psc_dma_pcm_new(struct snd_card *card, struct snd_soc_dai *dai,
+			   struct snd_pcm *pcm)
+{
+	struct snd_soc_pcm_runtime *rtd = pcm->private_data;
+	size_t size = psc_dma_pcm_hardware.buffer_bytes_max;
+	int rc = 0;
+
+	dev_dbg(rtd->socdev->dev, "psc_dma_pcm_new(card=%p, dai=%p, pcm=%p)\n",
+		card, dai, pcm);
+
+	if (!card->dev->dma_mask)
+		card->dev->dma_mask = &psc_dma_pcm_dmamask;
+	if (!card->dev->coherent_dma_mask)
+		card->dev->coherent_dma_mask = 0xffffffff;
+
+	if (pcm->streams[0].substream) {
+		rc = snd_dma_alloc_pages(SNDRV_DMA_TYPE_DEV, pcm->dev, size,
+					&pcm->streams[0].substream->dma_buffer);
+		if (rc)
+			goto playback_alloc_err;
+	}
+
+	if (pcm->streams[1].substream) {
+		rc = snd_dma_alloc_pages(SNDRV_DMA_TYPE_DEV, pcm->dev, size,
+					&pcm->streams[1].substream->dma_buffer);
+		if (rc)
+			goto capture_alloc_err;
+	}
+
+	return 0;
+
+ capture_alloc_err:
+	if (pcm->streams[0].substream)
+		snd_dma_free_pages(&pcm->streams[0].substream->dma_buffer);
+ playback_alloc_err:
+	dev_err(card->dev, "Cannot allocate buffer(s)\n");
+	return -ENOMEM;
+}
+
+static void psc_dma_pcm_free(struct snd_pcm *pcm)
+{
+	struct snd_soc_pcm_runtime *rtd = pcm->private_data;
+	struct snd_pcm_substream *substream;
+	int stream;
+
+	dev_dbg(rtd->socdev->dev, "psc_dma_pcm_free(pcm=%p)\n", pcm);
+
+	for (stream = 0; stream < 2; stream++) {
+		substream = pcm->streams[stream].substream;
+		if (substream) {
+			snd_dma_free_pages(&substream->dma_buffer);
+			substream->dma_buffer.area = NULL;
+			substream->dma_buffer.addr = 0;
+		}
+	}
+}
+
+struct snd_soc_platform psc_dma_pcm_soc_platform = {
+	.name		= "mpc5200-psc-audio",
+	.pcm_ops	= &psc_dma_pcm_ops,
+	.pcm_new	= &psc_dma_pcm_new,
+	.pcm_free	= &psc_dma_pcm_free,
+};
diff --git a/sound/soc/fsl/mpc5200_dma.h b/sound/soc/fsl/mpc5200_dma.h
new file mode 100644
index 0000000..78ceec3
--- /dev/null
+++ b/sound/soc/fsl/mpc5200_dma.h
@@ -0,0 +1,19 @@
+/*
+ * Freescale MPC5200 Audio DMA driver
+ */
+
+#ifndef __SOUND_SOC_FSL_MPC5200_DMA_H__
+#define __SOUND_SOC_FSL_MPC5200_DMA_H__
+
+int mpc5200_dma_startup(struct snd_pcm_substream *substream,
+			   struct snd_soc_dai *dai);
+int mpc5200_dma_hw_free(struct snd_pcm_substream *substream,
+			   struct snd_soc_dai *dai);
+void mpc5200_dma_shutdown(struct snd_pcm_substream *substream,
+			     struct snd_soc_dai *dai);
+int mpc5200_dma_trigger(struct snd_pcm_substream *substream, int cmd,
+			   struct snd_soc_dai *dai);
+
+extern const struct snd_pcm_hardware mpc5200_pcm_hardware;
+
+#endif /* __SOUND_SOC_FSL_MPC5200_DMA_H__ */
diff --git a/sound/soc/fsl/mpc5200_psc_ac97.c b/sound/soc/fsl/mpc5200_psc_ac97.c
new file mode 100644
index 0000000..8392224
--- /dev/null
+++ b/sound/soc/fsl/mpc5200_psc_ac97.c
@@ -0,0 +1,402 @@
+/*
+ * linux/sound/mpc52xx-ac97.c -- AC97 support for the Freescale MPC52xx chip.
+ *
+ * Copyright 2008 Jon Smirl, Digispeaker
+ * Author: Jon Smirl <jonsmirl@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/interrupt.h>
+#include <linux/wait.h>
+#include <linux/delay.h>
+
+#include <sound/driver.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/ac97_codec.h>
+#include <sound/initval.h>
+#include <sound/soc.h>
+
+#include <asm/mpc52xx_psc.h>
+#include <asm/irq.h>
+#include <linux/mutex.h>
+
+#include "mpc52xx-dma.h"
+
+/* Private structure */
+struct mpc52xx_ac97_priv {
+	struct mpc52xx_dma_priv dma;
+	int irq;
+	struct mutex mutex;
+};
+
+#define DRV_NAME "mpc52xx-psc-ac97"
+
+static unsigned short mpc52xx_ac97_read(struct snd_ac97 *ac97, unsigned short reg)
+{
+	struct mpc52xx_ac97_priv *priv = ac97->private_data;
+	int timeout;
+	unsigned int val;
+
+	mutex_lock(&priv->mutex);
+	printk("ac97 read: reg %04x\n", reg);
+
+	/* Wait for it to be ready */
+	timeout = 1000;
+	while ((--timeout) && (in_be16(&priv->dma.psc->mpc52xx_psc_status) &
+						MPC52xx_PSC_SR_CMDSEND) )
+		udelay(10);
+
+	if (!timeout) {
+		printk(KERN_ERR DRV_NAME ": timeout on ac97 bus (rdy)\n");
+		return 0xffff;
+	}
+
+	/* Do the read */
+	out_be32(&priv->dma.psc->ac97_cmd, (1<<31) | ((reg & 0x7f) << 24));
+
+	/* Wait for the answer */
+	timeout = 1000;
+	while ((--timeout) && !(in_be16(&priv->dma.psc->mpc52xx_psc_status) &
+						MPC52xx_PSC_SR_DATA_VAL) )
+		udelay(10);
+
+	if (!timeout) {
+		printk(KERN_ERR DRV_NAME ": timeout on ac97 read (val)\n");
+		return 0xffff;
+	}
+
+	/* Get the data */
+	val = in_be32(&priv->dma.psc->ac97_data);
+	if ( ((val>>24) & 0x7f) != reg ) {
+		printk(KERN_ERR DRV_NAME ": reg echo error on ac97 read\n");
+		return 0xffff;
+	}
+	val = (val >> 8) & 0xffff;
+
+	printk("ac97 read ok: reg %04x  val %04x\n", reg, val);
+
+	mutex_unlock(&priv->mutex);
+	return (unsigned short) val;
+}
+
+static void mpc52xx_ac97_write(struct snd_ac97 *ac97, unsigned short reg, unsigned short val)
+{
+	struct mpc52xx_ac97_priv *priv = ac97->private_data;
+	int timeout;
+
+	//printk("ac97 write: reg %04x  val %04x\n", reg, val);
+	mutex_lock(&priv->mutex);
+
+	/* Wait for it to be ready */
+	timeout = 1000;
+	while ((--timeout) && (in_be16(&priv->dma.psc->mpc52xx_psc_status) &
+						MPC52xx_PSC_SR_CMDSEND) )
+		udelay(10);
+
+	if (!timeout) {
+		printk(KERN_ERR DRV_NAME ": timeout on ac97 write\n");
+		return;
+	}
+
+	/* Write data */
+	out_be32(&priv->dma.psc->ac97_cmd, ((reg & 0x7f) << 24) | (val << 8));
+	
+	mutex_unlock(&priv->mutex);
+}
+
+static void mpc52xx_ac97_cold_reset(struct snd_ac97 *ac97)
+{
+	struct mpc52xx_ac97_priv *priv = ac97->private_data;
+
+	printk("mpc52xx_ac97_cold_reset\n");
+
+	/* Do a cold reset */
+	out_8(&priv->dma.psc->op1, MPC52xx_PSC_OP_RES);
+	udelay(10);
+	out_8(&priv->dma.psc->op0, MPC52xx_PSC_OP_RES);
+	udelay(50);
+
+	/* PSC recover from cold reset (cfr user manual, not sure if useful) */
+	out_be32(&priv->dma.psc->sicr, in_be32(&priv->dma.psc->sicr));
+}
+
+static void mpc52xx_ac97_warm_reset(struct snd_ac97 *ac97)
+{
+	printk("mpc52xx_ac97_warm_reset\n");
+}
+
+static irqreturn_t mpc52xx_ac97_irq(int irq, void *dev_id)
+{
+	struct mpc52xx_ac97_priv *priv = dev_id;
+
+	static int icnt = 0;
+#if 1
+{
+	unsigned int val;
+	val = in_be32(&priv->dma.psc->ac97_data);
+	printk(KERN_INFO "mpc52xx_ac97_irq fired (isr=%04x, status=%04x) %08x\n", in_be16(&priv->dma.psc->mpc52xx_psc_imr), in_be16(&priv->dma.psc->mpc52xx_psc_status), val);
+	out_8(&priv->dma.psc->command,MPC52xx_PSC_RST_ERR_STAT);
+}
+#endif
+
+	/* Anti Crash during dev ;) */
+#if 1
+	if ((icnt++) > 5000)
+		out_be16(&priv->dma.psc->mpc52xx_psc_imr, 0);
+#endif
+
+	/* Print statuts */
+	printk(KERN_DEBUG "isr: %04x", in_be16(&priv->dma.psc->mpc52xx_psc_imr));
+	out_8(&priv->dma.psc->command,MPC52xx_PSC_RST_ERR_STAT);
+
+	return IRQ_HANDLED;
+}
+
+static struct snd_ac97_bus_ops mpc52xx_ac97_ops = {
+	.read		= mpc52xx_ac97_read,
+	.write		= mpc52xx_ac97_write,
+	.reset		= mpc52xx_ac97_cold_reset,
+	.warm_reset	= mpc52xx_ac97_warm_reset,
+};
+
+
+#ifdef CONFIG_PM
+static int mpc52xx_ac97_suspend(struct device *dev, pm_message_t state)
+{
+	return 0;
+}
+
+static int mpc52xx_ac97_resume(struct device *dev)
+{
+	return 0;
+}
+
+#else
+#define mpc52xx_ac97_suspend	NULL
+#define mpc52xx_ac97_resume	NULL
+#endif
+
+static int mpc52xx_ac97_hw_analog_params(struct snd_pcm_substream *substream,
+	struct snd_pcm_hw_params *params, struct snd_soc_dai_runtime *cpu_dai)
+{
+	struct mpc52xx_ac97_priv *priv = cpu_dai->private_data;
+	
+	printk("mpc52xx_ac97_hw_analog_params\n");
+	printk("channels %d\n",substream->runtime->channels);
+	printk("rate %d\n",substream->runtime->rate);
+	printk("periods %d\n",substream->runtime->periods);
+	printk("tick_time %d\n",substream->runtime->tick_time);
+	printk("period_step %d\n",substream->runtime->period_step);
+	printk("slots %d\n",priv->dma.psc->ac97_slots);
+
+	/* FIXME, need a spinlock to protect access */
+	if (substream->runtime->channels == 1)
+		out_be32(&priv->dma.psc->ac97_slots, 0x01000000);
+	else
+		out_be32(&priv->dma.psc->ac97_slots, 0x03000000);
+
+	return 0;
+}
+
+static int mpc52xx_ac97_hw_digital_params(struct snd_pcm_substream *substream,
+	struct snd_pcm_hw_params *params, struct snd_soc_dai_runtime *cpu_dai)
+{
+	return 0;
+}
+
+static int mpc52xx_ac97_new(struct snd_soc_dai_runtime *cpu_dai)
+{
+	printk("mpc52xx_ac97_new\n");
+	
+	return 0;
+}
+
+static void mpc52xx_ac97_free(struct snd_soc_dai_runtime *cpu_dai)
+{
+	//struct mpc52xx_ac97_priv *priv = cpu_dai->private_data;
+	
+	printk("mpc52xx_ac97_free\n");
+}
+
+static struct snd_soc_dai mpc52xx_dai_ac97[] = {
+{	
+	.name	= "mpc52xx AC97 analog",
+	.id	= MPC52XX_DAI_AC97_ANALOG,
+	.ac97_control	= 1,
+	.new	= mpc52xx_ac97_new,
+	.free	= mpc52xx_ac97_free,
+	
+	.playback = {
+		.stream_name	= "mpc52xx AC97 analog",
+		.channels_min	= 1,
+		.channels_max	= 6,
+		.rates		= SNDRV_PCM_RATE_8000_48000,
+		.formats	= SNDRV_PCM_FORMAT_S32_BE,
+	},
+	.capture = {
+		.stream_name	= "mpc52xx AC97 analog",
+		.channels_min	= 1,
+		.channels_max	= 2,
+		.rates		= SNDRV_PCM_RATE_8000_48000,
+		.formats	= SNDRV_PCM_FMTBIT_S32_BE,
+	},
+	/* alsa ops */
+	.hw_params	= mpc52xx_ac97_hw_analog_params,
+	/* ac97_ops */
+	.ac97_ops 	= &mpc52xx_ac97_ops,
+},
+{	
+	.name	= "mpc52xx AC97 digital",
+	.id	= MPC52XX_DAI_AC97_DIGITAL,
+	
+	.playback = {
+		.stream_name	= "mpc52xx AC97 digital",
+		.channels_min	= 1,
+		.channels_max	= 2,
+		.rates		= SNDRV_PCM_RATE_32000 | \
+			SNDRV_PCM_RATE_44100 | SNDRV_PCM_RATE_48000,
+		.formats	= SNDRV_PCM_FORMAT_IEC958_SUBFRAME_BE,
+	},
+	/* alsa ops */
+	.hw_params 	= mpc52xx_ac97_hw_digital_params,
+	/* ac97_ops */
+	.ac97_ops 	= &mpc52xx_ac97_ops,
+}};
+
+static void mpc52xx_ac97_hwinit(struct mpc52xx_ac97_priv *priv)
+{
+	printk("mpc52xx_ac97_hwinit\n");
+	
+	/* Reset everything first by safety */
+	out_8(&priv->dma.psc->command, MPC52xx_PSC_RST_RX);
+	out_8(&priv->dma.psc->command, MPC52xx_PSC_RST_TX);
+	out_8(&priv->dma.psc->command, MPC52xx_PSC_RST_ERR_STAT);
+
+	/* Do a cold reset of codec */
+	out_8(&priv->dma.psc->op1, MPC52xx_PSC_OP_RES);
+	udelay(10);
+	out_8(&priv->dma.psc->op0, MPC52xx_PSC_OP_RES);
+	udelay(50);
+
+	/* Configure AC97 enhanced mode */
+	out_be32(&priv->dma.psc->sicr, MPC52xx_PSC_SICR_ENC97 | MPC52xx_PSC_SICR_SYNCPOL | MPC52xx_PSC_SICR_CLKPOL);
+
+	/* No slots active */
+	out_be32(&priv->dma.psc->ac97_slots, 0x00000000);
+
+	/* No IRQ */
+	out_be16(&priv->dma.psc->mpc52xx_psc_imr, 0x0000);
+
+	/* FIFO levels */
+	out_8(&priv->dma.psc->rfcntl, 0x07);
+	out_8(&priv->dma.psc->tfcntl, 0x07);
+	out_be16(&priv->dma.psc->rfalarm, 0x80);
+	out_be16(&priv->dma.psc->tfalarm, 0x80);
+
+	/* Go */
+	out_8(&priv->dma.psc->command, MPC52xx_PSC_TX_ENABLE);
+	out_8(&priv->dma.psc->command, MPC52xx_PSC_RX_ENABLE);
+}
+
+static int mpc52xx_ac97_probe(struct device *dev)
+{
+	struct mpc52xx_ac97_priv *priv;
+	struct of_device *op;
+	struct snd_soc_platform *platform = to_snd_soc_platform(dev);
+	int rv;
+	
+	printk(KERN_INFO "MPC52xx SoC Audio PCM driver\n");
+
+	priv = kzalloc(sizeof(*priv), GFP_KERNEL);
+	if (priv == NULL)
+		return -ENOMEM;
+		
+	mutex_init(&priv->mutex);
+	platform->private_data = priv;
+	op = platform->machine->private_data;
+	platform->machine->private_data = priv;
+	
+	rv = mpc52xx_dma_setup(&priv->dma, platform, op);
+	if (rv < 0)
+		return rv;
+	
+	mpc52xx_ac97_hwinit(priv);
+
+	priv->irq = irq_of_parse_and_map(op->node, 0);
+	if (priv->irq == NO_IRQ) {
+		rv = -ENXIO;
+		goto fail_irq;
+	}
+	
+	printk("Requesting IRQ %d\n", priv->irq);
+	rv = request_irq(priv->irq, mpc52xx_ac97_irq,
+						IRQF_SHARED, DRV_NAME, priv);
+	if (rv < 0) {
+		printk(KERN_ERR "mpc52xx_ac97 - failed to attach interrupt\n");
+		rv = -ENXIO;
+		goto fail_request;
+	}
+
+	mpc52xx_dma_enable(&priv->dma);
+	
+	rv = snd_soc_platform_add_dai(platform, mpc52xx_dai_ac97, 3, priv);
+	if (rv < 0)
+		return rv;
+		
+	return snd_soc_register_platform(platform);
+
+fail_request:	
+fail_irq:
+	return rv;
+}
+
+static int mpc52xx_ac97_remove(struct device *dev)
+{
+	struct snd_soc_platform *platform = to_snd_soc_platform(dev);
+	struct mpc52xx_ac97_priv *priv = platform->private_data;
+	
+    if (priv->irq != NO_IRQ)
+    	irq_dispose_mapping(priv->irq);
+
+	mpc52xx_dma_cleanup(platform->private_data);
+	snd_soc_unregister_platform(platform);
+	return 0;
+}
+
+const char mpc_ac97_id[] = "mpc52xx-ac97";
+EXPORT_SYMBOL_GPL(mpc_ac97_id);
+
+static struct device_driver mpc52xx_ac97_driver = {
+	.name 		= mpc_ac97_id,
+	.owner		= THIS_MODULE,
+	.bus 		= &asoc_bus_type,
+	.probe		= mpc52xx_ac97_probe,
+	.remove		= __devexit_p(mpc52xx_ac97_remove),
+	.suspend	= mpc52xx_ac97_suspend,
+	.resume		= mpc52xx_ac97_resume,
+};
+
+static __init int mpc52xx_ac97_init(void)
+{
+	printk("mpc52xx_ac97_init\n");
+	return driver_register(&mpc52xx_ac97_driver);
+}
+
+static __exit void mpc52xx_ac97_exit(void)
+{
+	driver_unregister(&mpc52xx_ac97_driver);
+}
+
+module_init(mpc52xx_ac97_init);
+module_exit(mpc52xx_ac97_exit);
+
+MODULE_AUTHOR("Jon Smirl");
+MODULE_DESCRIPTION("MPC52xx AC97 module");
+MODULE_LICENSE("GPL");

Bottom: da682c04035d02a454fcb096a2209541787be460
Top:    c9e17d8620db66b01693ddf8db69fc71e6bd7cbc
Author: Jon Smirl <jonsmirl@gmail.com>
Date:   2009-05-22 09:27:13 -0400

Refresh of temp

---

diff --git a/arch/powerpc/include/asm/mpc52xx_psc.h b/arch/powerpc/include/asm/mpc52xx_psc.h
index c323f4f..fb84120 100644
--- a/arch/powerpc/include/asm/mpc52xx_psc.h
+++ b/arch/powerpc/include/asm/mpc52xx_psc.h
@@ -127,6 +127,7 @@
 #define MPC52xx_PSC_SICR_SIM_FIR		(0x6 << 24)
 #define MPC52xx_PSC_SICR_SIM_CODEC_24		(0x7 << 24)
 #define MPC52xx_PSC_SICR_SIM_CODEC_32		(0xf << 24)
+#define MPC52xx_PSC_SICR_AWR			(1 << 30)
 #define MPC52xx_PSC_SICR_GENCLK			(1 << 23)
 #define MPC52xx_PSC_SICR_I2S			(1 << 22)
 #define MPC52xx_PSC_SICR_CLKPOL			(1 << 21)
diff --git a/sound/soc/fsl/mpc5200_psc_ac97.c b/sound/soc/fsl/mpc5200_psc_ac97.c
index e6a77ab..6230c09 100644
--- a/sound/soc/fsl/mpc5200_psc_ac97.c
+++ b/sound/soc/fsl/mpc5200_psc_ac97.c
@@ -112,20 +112,26 @@ static void psc_ac97_write(struct snd_ac97 *ac97, unsigned short reg, unsigned s
 static void psc_ac97_cold_reset(struct snd_ac97 *ac97)
 {
 	struct psc_dma *psc_dma = ac97->private_data;
+	struct mpc52xx_psc __iomem *regs = psc_dma->psc_regs;
 
 	/* Do a cold reset */
-	out_8(&psc_dma->psc_regs->op1, MPC52xx_PSC_OP_RES);
+	out_8(&regs->op1, MPC52xx_PSC_OP_RES);
 	udelay(10);
-	out_8(&psc_dma->psc_regs->op0, MPC52xx_PSC_OP_RES);
+	out_8(&regs->op0, MPC52xx_PSC_OP_RES);
 	udelay(50);
 
 	/* PSC recover from cold reset (cfr user manual, not sure if useful) */
-	out_be32(&psc_dma->psc_regs->sicr, in_be32(&psc_dma->psc_regs->sicr));
+	out_be32(&regs->sicr, in_be32(&regs->sicr));
 }
 
 static void psc_ac97_warm_reset(struct snd_ac97 *ac97)
 {
-	pr_info("psc_ac97_warm_reset\n");
+	struct psc_dma *psc_dma = ac97->private_data;
+	struct mpc52xx_psc __iomem *regs = psc_dma->psc_regs;
+
+	out_be32(&regs->sicr, psc_dma->sicr | MPC52xx_PSC_SICR_AWR);
+	udelay(3);
+	out_be32(&regs->sicr, psc_dma->sicr);
 }
 
 struct snd_ac97_bus_ops soc_ac97_ops = {
@@ -306,33 +312,64 @@ static struct snd_soc_dai psc_ac97_dai_template[] = {
 static int __devinit psc_ac97_of_probe(struct of_device *op,
 				      const struct of_device_id *match)
 {
-	int rc;
+	int rc, id1, id2, timeout, max_reset;
 	struct psc_dma *psc_dma;
+	struct snd_ac97 ac97;
+	struct mpc52xx_psc __iomem *regs;
 
 	rc = mpc5200_audio_dma_create(op, psc_ac97_dai_template, ARRAY_SIZE(psc_ac97_dai_template));
 	if (rc != 0)
 		return rc;
 
 	psc_dma = dev_get_drvdata(&op->dev);
+	regs = psc_dma->psc_regs;
+	ac97.private_data = psc_dma;
 
 	psc_dma->imr = 0;
 	out_be16(&psc_dma->psc_regs->isr_imr.imr, psc_dma->imr);
 
-	out_8(&psc_dma->psc_regs->op1, MPC52xx_PSC_OP_RES);
-	udelay(10);
-	out_8(&psc_dma->psc_regs->op0, MPC52xx_PSC_OP_RES);
-	udelay(50);
-
 	/* Configure the serial interface mode to AC97 */
 	psc_dma->sicr = MPC52xx_PSC_SICR_SIM_AC97 | MPC52xx_PSC_SICR_ENAC97;
-	out_be32(&psc_dma->psc_regs->sicr, psc_dma->sicr);
+	out_be32(&regs->sicr, psc_dma->sicr);
 
 	/* No slots active */
-	out_be32(&psc_dma->psc_regs->ac97_slots, 0x00000000);
+	out_be32(&regs->ac97_slots, 0x00000000);
+
+	/* AC97 clock is generated by the codec.
+	 * Ensure that it starts ticking after codec reset.
+	 */
+	max_reset = 0;
+reset:
+	if (max_reset++ > 5) {
+		dev_err(&op->dev, "AC97 codec failed to reset\n");
+		mpc5200_audio_dma_destroy(op);
+		return -ENODEV;
+	}
+
+	psc_ac97_cold_reset(&ac97);
+
+	/* first make sure it is low */
+	timeout = 0;
+	while ((in_8(&regs->ipcr_acr.ipcr) & 0x80) != 0) {
+		udelay(1);
+		if (timeout++ > 1000)
+			goto reset;
+	}
+	/* then wait for the transition to high */
+	timeout = 0;
+	while ((in_8(&regs->ipcr_acr.ipcr) & 0x80) == 0) {
+		udelay(1);
+		if (timeout++ > 1000)
+			goto reset;
+	}
+
+	out_8(&regs->command, MPC52xx_PSC_TX_ENABLE | MPC52xx_PSC_RX_ENABLE);
 
 	/* Go */
-	out_8(&psc_dma->psc_regs->command, MPC52xx_PSC_TX_ENABLE);
-	out_8(&psc_dma->psc_regs->command, MPC52xx_PSC_RX_ENABLE);
+	id1 = psc_ac97_read(&ac97, AC97_VENDOR_ID1);
+	id2 = psc_ac97_read(&ac97, AC97_VENDOR_ID2);
+
+	printk("Codec ID is %04x %04x\n", id1, id2);
 
 	return 0;
 }

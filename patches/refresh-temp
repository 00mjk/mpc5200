Bottom: c2731e8dd69fd23f086523596cd7b08afee48826
Top:    1399c40996ea400aae1292daf8d40a0c04f05e85
Author: Jon Smirl <jonsmirl@gmail.com>
Date:   2009-05-25 17:59:15 -0400

Refresh of mpc5200-dma

---

diff --git a/sound/soc/fsl/mpc5200_dma.c b/sound/soc/fsl/mpc5200_dma.c
index 4e1f1f8..efec33a 100644
--- a/sound/soc/fsl/mpc5200_dma.c
+++ b/sound/soc/fsl/mpc5200_dma.c
@@ -85,6 +85,7 @@ static irqreturn_t psc_dma_bcom_irq_tx(int irq, void *_psc_dma_stream)
 {
 	struct psc_dma_stream *s = _psc_dma_stream;
 
+	spin_lock(&s->psc_dma->lock);
 	/* For each finished period, dequeue the completed period buffer
 	 * and enqueue a new one in it's place. */
 	while (bcom_buffer_done(s->bcom_task)) {
@@ -95,6 +96,7 @@ static irqreturn_t psc_dma_bcom_irq_tx(int irq, void *_psc_dma_stream)
 			s->period_current_pt = s->period_start;
 	}
 	psc_dma_bcom_enqueue_tx(s);
+	spin_unlock(&s->psc_dma->lock);
 
 	/* If the stream is active, then also inform the PCM middle layer
 	 * of the period finished event. */
@@ -108,6 +110,7 @@ static irqreturn_t psc_dma_bcom_irq_rx(int irq, void *_psc_dma_stream)
 {
 	struct psc_dma_stream *s = _psc_dma_stream;
 
+	spin_lock(&s->psc_dma->lock);
 	/* For each finished period, dequeue the completed period buffer
 	 * and enqueue a new one in it's place. */
 	while (bcom_buffer_done(s->bcom_task)) {
@@ -119,6 +122,7 @@ static irqreturn_t psc_dma_bcom_irq_rx(int irq, void *_psc_dma_stream)
 
 		psc_dma_bcom_enqueue_next_buffer(s);
 	}
+	spin_unlock(&s->psc_dma->lock);
 
 	/* If the stream is active, then also inform the PCM middle layer
 	 * of the period finished event. */
@@ -182,6 +186,8 @@ static int psc_dma_trigger(struct snd_pcm_substream *substream, int cmd)
 		/* Fill up the bestcomm bd queue and enable DMA.
 		 * This will begin filling the PSC's fifo.
 		 */
+		spin_lock_irqsave(&psc_dma->lock, flags);
+
 		if (substream->pstr->stream == SNDRV_PCM_STREAM_CAPTURE) {
 			bcom_gen_bd_rx_reset(s->bcom_task);
 			for (i = 0; i < runtime->periods; i++)
@@ -193,21 +199,22 @@ static int psc_dma_trigger(struct snd_pcm_substream *substream, int cmd)
 		}
 
 		bcom_enable(s->bcom_task);
+		spin_unlock_irqrestore(&psc_dma->lock, flags);
 
-		spin_lock_irqsave(&psc_dma->lock, flags);
 		out_8(&regs->command, MPC52xx_PSC_RST_ERR_STAT);
-		spin_unlock_irqrestore(&psc_dma->lock, flags);
 
 		break;
 
 	case SNDRV_PCM_TRIGGER_STOP:
 		s->active = 0;
 
+		spin_lock_irqsave(&psc_dma->lock, flags);
 		bcom_disable(s->bcom_task);
 		if (substream->pstr->stream == SNDRV_PCM_STREAM_CAPTURE)
 			bcom_gen_bd_rx_reset(s->bcom_task);
 		else
 			bcom_gen_bd_tx_reset(s->bcom_task);
+		spin_unlock_irqrestore(&psc_dma->lock, flags);
 
 		break;
 
@@ -415,72 +422,6 @@ struct snd_soc_platform mpc5200_audio_dma_platform = {
 };
 EXPORT_SYMBOL_GPL(mpc5200_audio_dma_platform);
 
-/* ---------------------------------------------------------------------
- * Sysfs attributes for error monitoring
- */
-
-static ssize_t psc_dma_status_show(struct device *dev,
-			   struct device_attribute *attr, char *buf)
-{
-	struct psc_dma *psc_dma = dev_get_drvdata(dev);
-
-	return sprintf(buf, "status=%.4x sicr=%.8x rfnum=%i rfstat=0x%.4x "
-			"tfnum=%i tfstat=0x%.4x\n",
-			in_be16(&psc_dma->psc_regs->sr_csr.status),
-			in_be32(&psc_dma->psc_regs->sicr),
-			in_be16(&psc_dma->fifo_regs->rfnum) & 0x1ff,
-			in_be16(&psc_dma->fifo_regs->rfstat),
-			in_be16(&psc_dma->fifo_regs->tfnum) & 0x1ff,
-			in_be16(&psc_dma->fifo_regs->tfstat));
-}
-
-static unsigned long *psc_dma_get_stat_attr(struct psc_dma *psc_dma,
-							const char *name)
-{
-	if (strcmp(name, "playback_underrun") == 0)
-		return &psc_dma->stats.underrun_count;
-	if (strcmp(name, "capture_overrun") == 0)
-		return &psc_dma->stats.overrun_count;
-
-	return 0;
-}
-
-static ssize_t psc_dma_stat_show(struct device *dev,
-				 struct device_attribute *attr, char *buf)
-{
-	struct psc_dma *psc_dma = dev_get_drvdata(dev);
-	unsigned long *attrib;
-
-	attrib = psc_dma_get_stat_attr(psc_dma, attr->attr.name);
-	if (!attrib)
-		return 0;
-
-	return sprintf(buf, "%lu\n", *attrib);
-}
-
-static ssize_t psc_dma_stat_store(struct device *dev,
-				  struct device_attribute *attr,
-				  const char *buf,
-				  size_t count)
-{
-	struct psc_dma *psc_dma = dev_get_drvdata(dev);
-	unsigned long *attrib;
-
-	attrib = psc_dma_get_stat_attr(psc_dma, attr->attr.name);
-	if (!attrib)
-		return 0;
-
-	strict_strtoul(buf, 10, attrib);
-	return count;
-}
-
-static DEVICE_ATTR(status, 0644, psc_dma_status_show, NULL);
-static DEVICE_ATTR(playback_underrun, 0644, psc_dma_stat_show,
-			psc_dma_stat_store);
-static DEVICE_ATTR(capture_overrun, 0644, psc_dma_stat_show,
-			psc_dma_stat_store);
-
-
 int mpc5200_audio_dma_create(struct of_device *op)
 {
 	phys_addr_t fifo;
@@ -589,13 +530,6 @@ int mpc5200_audio_dma_create(struct of_device *op)
 	/* Save what we've done so it can be found again later */
 	dev_set_drvdata(&op->dev, psc_dma);
 
-	/* Register the SYSFS files */
-	rc = device_create_file(psc_dma->dev, &dev_attr_status);
-	rc |= device_create_file(psc_dma->dev, &dev_attr_capture_overrun);
-	rc |= device_create_file(psc_dma->dev, &dev_attr_playback_underrun);
-	if (rc)
-		dev_info(psc_dma->dev, "error creating sysfs files\n");
-
 	/* Tell the ASoC OF helpers about it */
 	return snd_soc_register_platform(&mpc5200_audio_dma_platform);
 }
diff --git a/sound/soc/fsl/mpc5200_dma.h b/sound/soc/fsl/mpc5200_dma.h
index 2000803..7414c6f 100644
--- a/sound/soc/fsl/mpc5200_dma.h
+++ b/sound/soc/fsl/mpc5200_dma.h
@@ -77,4 +77,18 @@ int mpc5200_audio_dma_destroy(struct of_device *op);
 
 extern struct snd_soc_platform mpc5200_audio_dma_platform;
 
+/* whack this after Timur's patch is merged in to arch/powerpc/include/asm/delay.h */
+#define spin_event_timeout(condition, timeout, delay, rc)                   \
+{                                                                           \
+       unsigned long __loops = tb_ticks_per_usec * timeout;                \
+       unsigned long __start = get_tbl();                                  \
+       while ((rc = (condition)) && (tb_ticks_since(__start) <= __loops)) \
+               if (delay)                                                  \
+                       udelay(delay);                                      \
+               else                                                        \
+                       cpu_relax();                                        \
+}
+/* whack this after Timur's patch is merged in to arch/powerpc/include/asm/delay.h */
+
+
 #endif /* __SOUND_SOC_FSL_MPC5200_DMA_H__ */

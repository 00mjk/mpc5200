Bottom: f1686e688df34ec7afd1fa8a2dcb13f97a4bea3e
Top:    0defe5df901810e79d23bd2aef91b2ee6bbbd48e
Author: Jon Smirl <jonsmirl@gmail.com>
Date:   2009-05-24 17:36:25 -0400

Refresh of mpc5200-ac97

---

diff --git a/sound/soc/fsl/mpc5200_psc_ac97.c b/sound/soc/fsl/mpc5200_psc_ac97.c
index fa1bb9a..56dac55 100644
--- a/sound/soc/fsl/mpc5200_psc_ac97.c
+++ b/sound/soc/fsl/mpc5200_psc_ac97.c
@@ -94,27 +94,61 @@ static void psc_ac97_write(struct snd_ac97 *ac97, unsigned short reg, unsigned s
 	spin_unlock(&psc_dma->lock);
 }
 
-static void psc_ac97_cold_reset(struct snd_ac97 *ac97)
+static void psc_ac97_warm_reset(struct snd_ac97 *ac97)
 {
 	struct mpc52xx_psc __iomem *regs = psc_dma->psc_regs;
 
-	/* Do a cold reset */
-	out_8(&regs->op1, MPC52xx_PSC_OP_RES);
-	udelay(10);
-	out_8(&regs->op0, MPC52xx_PSC_OP_RES);
-	udelay(50);
-
-	/* PSC recover from cold reset (cfr user manual, not sure if useful) */
-	out_be32(&regs->sicr, in_be32(&regs->sicr));
+	out_be32(&regs->sicr, psc_dma->sicr | MPC52xx_PSC_SICR_AWR);
+	udelay(3);
+	out_be32(&regs->sicr, psc_dma->sicr);
 }
 
-static void psc_ac97_warm_reset(struct snd_ac97 *ac97)
+static int psc_ac97_cold_reset_check(struct snd_ac97 *ac97)
 {
+	int max_reset, timeout;
 	struct mpc52xx_psc __iomem *regs = psc_dma->psc_regs;
 
-	out_be32(&regs->sicr, psc_dma->sicr | MPC52xx_PSC_SICR_AWR);
-	udelay(3);
-	out_be32(&regs->sicr, psc_dma->sicr);
+	/* AC97 clock is generated by the codec.
+	 * Ensure that it starts ticking after codec reset.
+	 */
+	for (max_reset = 0; max_reset < 5; max_reset++) {
+
+		/* Do a cold reset */
+		out_8(&regs->op1, MPC52xx_PSC_OP_RES);
+		udelay(10);
+		out_8(&regs->op0, MPC52xx_PSC_OP_RES);
+		udelay(50);
+
+		/* PSC recover from cold reset (cfr user manual, not sure if useful) */
+		out_be32(&regs->sicr, in_be32(&regs->sicr));
+
+		psc_ac97_warm_reset(ac97);
+
+		/* first make sure AC97 clock is low */
+		for (timeout = 0; ((in_8(&regs->ipcr_acr.ipcr) & 0x80) != 0) &&
+				(timeout < 100); timeout++)
+			udelay(10);
+		if (timeout == 100)
+			continue;
+
+		/* then wait for the transition to high */
+		for (timeout = 0; ((in_8(&regs->ipcr_acr.ipcr) & 0x80) == 0) &&
+				(timeout < 100); timeout++)
+			udelay(10);
+		if (timeout == 100)
+			continue;
+
+		break;
+	}
+	if (max_reset == 5)
+		return -ENODEV;
+	return 0;
+}
+
+static void psc_ac97_cold_reset(struct snd_ac97 *ac97)
+{
+	psc_ac97_cold_reset_check(ac97);
+
 }
 
 struct snd_ac97_bus_ops soc_ac97_ops = {
@@ -125,28 +159,11 @@ struct snd_ac97_bus_ops soc_ac97_ops = {
 };
 EXPORT_SYMBOL_GPL(soc_ac97_ops);
 
-#ifdef CONFIG_PM
-static int psc_ac97_suspend(struct snd_soc_dai *dai)
-{
-	return 0;
-}
-
-static int psc_ac97_resume(struct snd_soc_dai *dai)
-{
-	return 0;
-}
-
-#else
-#define psc_ac97_suspend	NULL
-#define psc_ac97_resume	NULL
-#endif
-
 static int psc_ac97_hw_analog_params(struct snd_pcm_substream *substream,
 				 struct snd_pcm_hw_params *params,
-				 struct snd_soc_dai *dai)
+				 struct snd_soc_dai *cpu_dai)
 {
-	struct snd_soc_pcm_runtime *rtd = substream->private_data;
-	struct psc_dma *psc_dma = rtd->dai->cpu_dai->private_data;
+	struct psc_dma *psc_dma = cpu_dai->private_data;
 
 	dev_dbg(psc_dma->dev, "%s(substream=%p) p_size=%i p_bytes=%i"
 		" periods=%i buffer_size=%i  buffer_bytes=%i channels=%i"
@@ -178,10 +195,9 @@ static int psc_ac97_hw_analog_params(struct snd_pcm_substream *substream,
 
 static int psc_ac97_hw_digital_params(struct snd_pcm_substream *substream,
 				 struct snd_pcm_hw_params *params,
-				 struct snd_soc_dai *dai)
+				 struct snd_soc_dai *cpu_dai)
 {
-	struct snd_soc_pcm_runtime *rtd = substream->private_data;
-	struct psc_dma *psc_dma = rtd->dai->cpu_dai->private_data;
+	struct psc_dma *psc_dma = cpu_dai->private_data;
 
 	spin_lock(&psc_dma->lock);
 	if (params_channels(params) == 1)
@@ -194,7 +210,7 @@ static int psc_ac97_hw_digital_params(struct snd_pcm_substream *substream,
 }
 
 static int psc_ac97_trigger(struct snd_pcm_substream *substream, int cmd,
-								 struct snd_soc_dai *dai)
+							struct snd_soc_dai *dai)
 {
 	struct snd_soc_pcm_runtime *rtd = substream->private_data;
 	struct psc_dma *psc_dma = rtd->dai->cpu_dai->private_data;
@@ -236,8 +252,7 @@ static struct snd_soc_dai_ops psc_ac97_digital_ops = {
 struct snd_soc_dai psc_ac97_dai[] = {
 {
 	.name   = "AC97",
-	.suspend = psc_ac97_suspend,
-	.resume = psc_ac97_resume,
+	.ac97_control = 1,
 	.playback = {
 		.channels_min   = 1,
 		.channels_max   = 6,
@@ -254,6 +269,7 @@ struct snd_soc_dai psc_ac97_dai[] = {
 },
 {
 	.name   = "SPDIF",
+	.ac97_control = 1,
 	.playback = {
 		.channels_min   = 1,
 		.channels_max   = 2,
@@ -275,7 +291,7 @@ EXPORT_SYMBOL_GPL(psc_ac97_dai);
 static int __devinit psc_ac97_of_probe(struct of_device *op,
 				      const struct of_device_id *match)
 {
-	int rc, i, id1, id2, timeout, max_reset;
+	int rc, i, id1, id2;
 	struct snd_ac97 ac97;
 	struct mpc52xx_psc __iomem *regs;
 
@@ -288,8 +304,8 @@ static int __devinit psc_ac97_of_probe(struct of_device *op,
 
 	rc = snd_soc_register_dais(psc_ac97_dai, ARRAY_SIZE(psc_ac97_dai));
 	if (rc != 0) {
-		pr_err("Failed to register DAI\n");
-		return 0;
+		dev_err(&op->dev, "Failed to register DAI\n");
+		return rc;
 	}
 
 	psc_dma = dev_get_drvdata(&op->dev);
@@ -312,40 +328,16 @@ static int __devinit psc_ac97_of_probe(struct of_device *op,
 	/* AC97 clock is generated by the codec.
 	 * Ensure that it starts ticking after codec reset.
 	 */
-	max_reset = 0;
-reset:
-	if (max_reset++ > 5) {
+	rc = psc_ac97_cold_reset_check(&ac97);
+	if (rc != 0) {
 		dev_err(&op->dev, "AC97 codec failed to reset\n");
 		mpc5200_audio_dma_destroy(op);
-		return -ENODEV;
-	}
-
-	psc_ac97_cold_reset(&ac97);
-	psc_ac97_warm_reset(&ac97);
-
-	/* first make sure it is low */
-	timeout = 0;
-	while ((in_8(&regs->ipcr_acr.ipcr) & 0x80) != 0) {
-		udelay(1);
-		if (timeout++ > 1000)
-			goto reset;
-	}
-	/* then wait for the transition to high */
-	timeout = 0;
-	while ((in_8(&regs->ipcr_acr.ipcr) & 0x80) == 0) {
-		udelay(1);
-		if (timeout++ > 1000)
-			psc_ac97_warm_reset(&ac97);
+		return rc;
 	}
 
 	/* Go */
 	out_8(&regs->command, MPC52xx_PSC_TX_ENABLE | MPC52xx_PSC_RX_ENABLE);
 
-	id1 = psc_ac97_read(&ac97, AC97_VENDOR_ID1);
-	id2 = psc_ac97_read(&ac97, AC97_VENDOR_ID2);
-
-	dev_info(&op->dev, "Codec ID is %04x %04x\n", id1, id2);
-
 	return 0;
 }

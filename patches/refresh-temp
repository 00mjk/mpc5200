Bottom: c095b67391c8db5a5241af2678ca7cabc6bba2f8
Top:    6ce4d87c6a4a013723feffec8b3f771ff4691a83
Author: Jon Smirl <jonsmirl@gmail.com>
Date:   2008-12-30 09:41:10 -0500

Refresh of jds-lirc-gpt

---

diff --git a/drivers/input/ir/ir-gpt.c b/drivers/input/ir/ir-gpt.c
index ab83d89..41d2fa6 100644
--- a/drivers/input/ir/ir-gpt.c
+++ b/drivers/input/ir/ir-gpt.c
@@ -16,71 +16,36 @@
 #include <asm/io.h>
 #include <asm/mpc52xx.h>
 
-#define MAX_SAMPLES 200
-
 struct ir_gpt {
-	int irq;
-	struct mpc52xx_gpt __iomem *regs;
-	spinlock_t lock;
-	struct work_struct queue;
-	int head, tail, previous;
-	unsigned int samples[MAX_SAMPLES];
 	struct input_dev *input;
+	int irq, previous;
+	struct mpc52xx_gpt __iomem *regs;
 };
 
-static void ir_event(struct work_struct *work)
-{
-	unsigned long flags;
-	int delta, count;
-	unsigned int sample, wrap, bit;
-	struct ir_gpt *ir_gpt = container_of(work, struct ir_gpt, queue);
-
-	while (1) {
-		spin_lock_irqsave(ir_gpt->lock, flags);
-		if (ir_gpt->tail == ir_gpt->head) {
-			spin_unlock_irqrestore(ir_gpt->lock, flags);
-			break;
-		}
-		sample = ir_gpt->samples[ir_gpt->tail];
-
-		ir_gpt->tail++;
-		if (ir_gpt->tail >= MAX_SAMPLES)
-			ir_gpt->tail = 0;
-
-		spin_unlock_irqrestore(ir_gpt->lock, flags);
-
-		count = sample >> 16;
-		wrap = (sample >> 12) & 7;
-		bit = (sample >> 8) & 1;
-
-		delta = count - ir_gpt->previous;
-		delta += wrap * 0x10000;
-
-		ir_gpt->previous = count;
-
-		input_ir_decode(ir_gpt->input, delta, bit);
-	}
-}
-
 /*
  * Interrupt handlers
  */
 static irqreturn_t dpeak_ir_irq(int irq, void *_ir)
 {
-	unsigned long flags;
-	unsigned int sample, next;
 	struct ir_gpt *ir_gpt = _ir;
+	int sample, count, delta, bit, wrap;
 
 	sample = in_be32(&ir_gpt->regs->status);
 	out_be32(&ir_gpt->regs->status, 0xF);
 
-	spin_lock_irqsave(ir_gpt->lock, flags);
-	ir_gpt->samples[ir_gpt->head] = sample;
-	next = ir_gpt->head + 1;
-	ir_gpt->head = (next >= MAX_SAMPLES ? 0 : next);
-	spin_unlock_irqrestore(ir_gpt->lock, flags);
+	count = sample >> 16;
+	wrap = (sample >> 12) & 7;
+	bit = (sample >> 8) & 1;
+
+	delta = count - ir_gpt->previous;
+	delta += wrap * 0x10000;
 
-	schedule_work(&ir_gpt->queue);
+	ir_gpt->previous = count;
+
+	if (bit)
+		delta = -delta;
+
+	input_ir_queue(ir_gpt->input, delta);
 
 	return IRQ_HANDLED;
 }
@@ -129,9 +94,6 @@ static int __devinit ir_gpt_of_probe(struct of_device *op,
 	if (ret)
 		goto free_input;
 
-	spin_lock_init(&ir_gpt->lock);
-	INIT_WORK (&ir_gpt->queue, ir_event);
-
 	/* Fetch the registers and IRQ of the GPT */
 	if (of_address_to_resource(op->node, 0, &res)) {
 		dev_err(&op->dev, "Missing reg property\n");
@@ -170,7 +132,6 @@ static int __devinit ir_gpt_of_probe(struct of_device *op,
 	return 0;
 
 free_input:
-	input_ir_destroy(ir_gpt->input);
 	input_free_device(ir_gpt->input);
 free_mem:
 	kfree(ir_gpt);
@@ -183,8 +144,7 @@ static int __devexit ir_gpt_of_remove(struct of_device *op)
 
 	dev_dbg(&op->dev, "ir_gpt_remove()\n");
 
-	input_ir_destroy(ir_gpt->input);
-	input_free_device(ir_gpt->input);
+	input_unregister_device(ir_gpt->input);
 	kfree(ir_gpt);
 	dev_set_drvdata(&op->dev, NULL);

Bottom: 5e71c399127d183dcb1de784c8cc9212829cb542
Top:    9f645418c1018bb77c25c4bf21dea31cff3feeef
Author: Jon Smirl <jonsmirl@gmail.com>
Date:   2009-05-25 17:59:50 -0400

Refresh of mpc5200-ac97

---

diff --git a/sound/soc/fsl/mpc5200_psc_ac97.c b/sound/soc/fsl/mpc5200_psc_ac97.c
index 480b677..3e6838c 100644
--- a/sound/soc/fsl/mpc5200_psc_ac97.c
+++ b/sound/soc/fsl/mpc5200_psc_ac97.c
@@ -17,6 +17,8 @@
 #include <sound/pcm_params.h>
 #include <sound/soc.h>
 
+#include <asm/time.h>
+#include <asm/delay.h>
 #include <asm/mpc52xx_psc.h>
 
 #include "mpc5200_dma.h"
@@ -29,131 +31,76 @@ static struct psc_dma *psc_dma;
 
 static unsigned short psc_ac97_read(struct snd_ac97 *ac97, unsigned short reg)
 {
-	int timeout;
+	int rc;
 	unsigned int val;
 
-	spin_lock(&psc_dma->lock);
-
-	/* Wait for it to be ready */
-	timeout = 1000;
-	while ((--timeout) && (in_be16(&psc_dma->psc_regs->sr_csr.status) &
-						MPC52xx_PSC_SR_CMDSEND))
-		udelay(10);
-
-	if (!timeout) {
+	/* Wait for command send status zero = ready */
+	spin_event_timeout((in_be16(&psc_dma->psc_regs->sr_csr.status) &
+				MPC52xx_PSC_SR_CMDSEND), 100, 0, rc);
+	if (rc != 0) {
 		pr_err("timeout on ac97 bus (rdy)\n");
-		return 0xffff;
+		return -ENODEV;
 	}
-
-	/* Do the read */
+	/* Send the read */
 	out_be32(&psc_dma->psc_regs->ac97_cmd, (1<<31) | ((reg & 0x7f) << 24));
 
 	/* Wait for the answer */
-	timeout = 1000;
-	while ((--timeout) && !(in_be16(&psc_dma->psc_regs->sr_csr.status) &
-						MPC52xx_PSC_SR_DATA_VAL))
-		udelay(10);
-
-	if (!timeout) {
+	spin_event_timeout(!(in_be16(&psc_dma->psc_regs->sr_csr.status) &
+				MPC52xx_PSC_SR_DATA_VAL), 100, 0, rc);
+	if (rc != 0) {
 		pr_err("timeout on ac97 read (val) %x\n",
 				in_be16(&psc_dma->psc_regs->sr_csr.status));
-		return 0xffff;
+		return -ENODEV;
 	}
-
 	/* Get the data */
 	val = in_be32(&psc_dma->psc_regs->ac97_data);
-	if (((val>>24) & 0x7f) != reg) {
+	if (((val >> 24) & 0x7f) != reg) {
 		pr_err("reg echo error on ac97 read\n");
-		return 0xffff;
+		return -ENODEV;
 	}
 	val = (val >> 8) & 0xffff;
 
-	spin_unlock(&psc_dma->lock);
 	return (unsigned short) val;
 }
 
 static void psc_ac97_write(struct snd_ac97 *ac97,
 				unsigned short reg, unsigned short val)
 {
-	int timeout;
-
-	spin_lock(&psc_dma->lock);
+	int rc;
 
-	/* Wait for it to be ready */
-	timeout = 1000;
-	while ((--timeout) && (in_be16(&psc_dma->psc_regs->sr_csr.status) &
-						MPC52xx_PSC_SR_CMDSEND))
-		udelay(10);
-
-	if (!timeout) {
-		pr_err("timeout on ac97 write\n");
+	/* Wait for command status zero = ready */
+	spin_event_timeout((in_be16(&psc_dma->psc_regs->sr_csr.status) &
+				MPC52xx_PSC_SR_CMDSEND), 100, 0, rc);
+	if (rc != 0) {
+		pr_err("timeout on ac97 bus (write)\n");
 		return;
 	}
-
 	/* Write data */
 	out_be32(&psc_dma->psc_regs->ac97_cmd,
 			((reg & 0x7f) << 24) | (val << 8));
-
-	spin_unlock(&psc_dma->lock);
 }
 
 static void psc_ac97_warm_reset(struct snd_ac97 *ac97)
 {
+	int rc;
 	struct mpc52xx_psc __iomem *regs = psc_dma->psc_regs;
 
 	out_be32(&regs->sicr, psc_dma->sicr | MPC52xx_PSC_SICR_AWR);
-	udelay(3);
+	spin_event_timeout(1, 3, 0, rc);
 	out_be32(&regs->sicr, psc_dma->sicr);
 }
 
-static int psc_ac97_cold_reset_check(struct snd_ac97 *ac97)
-{
-	int max_reset, timeout;
-	struct mpc52xx_psc __iomem *regs = psc_dma->psc_regs;
-
-	/* AC97 clock is generated by the codec.
-	 * Ensure that it starts ticking after codec reset.
-	 */
-	for (max_reset = 0; max_reset < 5; max_reset++) {
-
-		/* Do a cold reset */
-		out_8(&regs->op1, MPC52xx_PSC_OP_RES);
-		udelay(10);
-		out_8(&regs->op0, MPC52xx_PSC_OP_RES);
-		udelay(50);
-
-		/* PSC recover from cold reset
-		 * (cfr user manual, not sure if useful)
-		 */
-		out_be32(&regs->sicr, in_be32(&regs->sicr));
-
-		psc_ac97_warm_reset(ac97);
-
-		/* first make sure AC97 clock is low */
-		for (timeout = 0; ((in_8(&regs->ipcr_acr.ipcr) & 0x80) != 0) &&
-				(timeout < 100); timeout++)
-			udelay(10);
-		if (timeout == 100)
-			continue;
-
-		/* then wait for the transition to high */
-		for (timeout = 0; ((in_8(&regs->ipcr_acr.ipcr) & 0x80) == 0) &&
-				(timeout < 100); timeout++)
-			udelay(10);
-		if (timeout == 100)
-			continue;
-
-		break;
-	}
-	if (max_reset == 5)
-		return -ENODEV;
-	return 0;
-}
-
 static void psc_ac97_cold_reset(struct snd_ac97 *ac97)
 {
-	psc_ac97_cold_reset_check(ac97);
+	int rc;
+	struct mpc52xx_psc __iomem *regs = psc_dma->psc_regs;
 
+	/* Do a cold reset */
+	out_8(&regs->op1, MPC52xx_PSC_OP_RES);
+	spin_event_timeout(1, 10, 0, rc);
+	out_8(&regs->op0, MPC52xx_PSC_OP_RES);
+	spin_event_timeout(1, 50, 0, rc);
+	psc_ac97_warm_reset(ac97);
 }
 
 struct snd_ac97_bus_ops soc_ac97_ops = {
@@ -191,10 +138,7 @@ static int psc_ac97_hw_analog_params(struct snd_pcm_substream *substream,
 		else
 			psc_dma->slots |= 0x03000000;
 	}
-
-	spin_lock(&psc_dma->lock);
 	out_be32(&psc_dma->psc_regs->ac97_slots, psc_dma->slots);
-	spin_unlock(&psc_dma->lock);
 
 	return 0;
 }
@@ -205,12 +149,10 @@ static int psc_ac97_hw_digital_params(struct snd_pcm_substream *substream,
 {
 	struct psc_dma *psc_dma = cpu_dai->private_data;
 
-	spin_lock(&psc_dma->lock);
 	if (params_channels(params) == 1)
 		out_be32(&psc_dma->psc_regs->ac97_slots, 0x01000000);
 	else
 		out_be32(&psc_dma->psc_regs->ac97_slots, 0x03000000);
-	spin_unlock(&psc_dma->lock);
 
 	return 0;
 }
@@ -228,14 +170,23 @@ static int psc_ac97_trigger(struct snd_pcm_substream *substream, int cmd,
 		else
 			psc_dma->slots &= 0x0000FFFF;
 
-		spin_lock(&psc_dma->lock);
 		out_be32(&psc_dma->psc_regs->ac97_slots, psc_dma->slots);
-		spin_unlock(&psc_dma->lock);
 		break;
 	}
 	return 0;
 }
 
+static int psc_ac97_probe(struct platform_device *pdev,
+					struct snd_soc_dai *cpu_dai)
+{
+	struct psc_dma *psc_dma = cpu_dai->private_data;
+	struct mpc52xx_psc __iomem *regs = psc_dma->psc_regs;
+
+	/* Go */
+	out_8(&regs->command, MPC52xx_PSC_TX_ENABLE | MPC52xx_PSC_RX_ENABLE);
+	return 0;
+}
+
 /* ---------------------------------------------------------------------
  * ALSA SoC Bindings
  *
@@ -259,6 +210,7 @@ struct snd_soc_dai psc_ac97_dai[] = {
 {
 	.name   = "AC97",
 	.ac97_control = 1,
+	.probe	= psc_ac97_probe,
 	.playback = {
 		.channels_min   = 1,
 		.channels_max   = 6,
@@ -297,7 +249,7 @@ EXPORT_SYMBOL_GPL(psc_ac97_dai);
 static int __devinit psc_ac97_of_probe(struct of_device *op,
 				      const struct of_device_id *match)
 {
-	int rc, i, id1, id2;
+	int rc, i;
 	struct snd_ac97 ac97;
 	struct mpc52xx_psc __iomem *regs;
 
@@ -331,19 +283,6 @@ static int __devinit psc_ac97_of_probe(struct of_device *op,
 	/* No slots active */
 	out_be32(&regs->ac97_slots, 0x00000000);
 
-	/* AC97 clock is generated by the codec.
-	 * Ensure that it starts ticking after codec reset.
-	 */
-	rc = psc_ac97_cold_reset_check(&ac97);
-	if (rc != 0) {
-		dev_err(&op->dev, "AC97 codec failed to reset\n");
-		mpc5200_audio_dma_destroy(op);
-		return rc;
-	}
-
-	/* Go */
-	out_8(&regs->command, MPC52xx_PSC_TX_ENABLE | MPC52xx_PSC_RX_ENABLE);
-
 	return 0;
 }

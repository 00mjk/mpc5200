Bottom: dd41d2f7cfd5744b31073b632a440e40ac7c11fa
Top:    225ce4801e49d3ee59cb758d9e9f4ca01ee835d0
Author: Jon Smirl <jonsmirl@gmail.com>
Date:   2008-10-29 23:46:48 -0400

Refresh of jds-lirc

---

diff --git a/drivers/input/ir-core.c b/drivers/input/ir-core.c
index 949a507..2ff3e2c 100644
--- a/drivers/input/ir-core.c
+++ b/drivers/input/ir-core.c
@@ -7,6 +7,7 @@
 #include <linux/kernel.h>
 #include <linux/device.h>
 #include <linux/input.h>
+#include <linux/configfs.h>
 
 #undef IR_PROTOCOL_DEBUG
 #ifdef IR_PROTOCOL_DEBUG
@@ -459,6 +460,213 @@ void input_ir_decode(struct input_dev *dev, unsigned int delta, unsigned int bit
 }
 EXPORT_SYMBOL_GPL(input_ir_decode);
 
+struct mapping {
+	struct config_item item;
+	int protocol;
+	int device;
+	int command;
+};
+
+static inline struct mapping *to_mapping(struct config_item *item)
+{
+	return item ? container_of(item, struct mapping, item) : NULL;
+}
+
+static void mapping_release(struct config_item *item)
+{
+	kfree(to_mapping(item));
+}
+
+static ssize_t mapping_attr_show(struct config_item *item,
+				      struct configfs_attribute *attr,
+				      char *page)
+{
+	ssize_t count;
+	struct mapping *mapping = to_mapping(item);
+
+	count = sprintf(page, "%d\n", mapping->protocol);
+
+	return count;
+}
+
+static ssize_t mapping_attr_store(struct config_item *item,
+				       struct configfs_attribute *attr,
+				       const char *page, size_t count)
+{
+	struct mapping *mapping = to_mapping(item);
+	unsigned long tmp;
+	char *p = (char *) page;
+
+	tmp = simple_strtoul(p, &p, 10);
+	if (!p || (*p && (*p != '\n')))
+		return -EINVAL;
+
+	if (tmp > INT_MAX)
+		return -ERANGE;
+
+	mapping->protocol = tmp;
+
+	return count;
+}
+
+static struct configfs_item_operations mapping_item_ops = {
+	.release		= mapping_release,
+	.show_attribute		= mapping_attr_show,
+	.store_attribute	= mapping_attr_store,
+};
+
+static struct configfs_attribute mapping_attr_protocol = {
+	.ca_owner = THIS_MODULE,
+	.ca_name = "protocol",
+	.ca_mode = S_IRUGO | S_IWUSR,
+};
+
+static struct configfs_attribute *mapping_attrs[] = {
+	&mapping_attr_protocol,
+	NULL,
+};
+
+static struct config_item_type mapping_type = {
+	.ct_item_ops	= &mapping_item_ops,
+	.ct_attrs	= mapping_attrs,
+	.ct_owner	= THIS_MODULE,
+};
+
+struct remote_map {
+	struct config_group group;
+};
+
+static inline struct remote_map *to_remote_map(struct config_item *item)
+{
+	return item ? container_of(to_config_group(item), struct remote_map, group) : NULL;
+}
+
+static struct config_item *remote_map_make_item(struct config_group *group, const char *name)
+{
+	struct mapping *mapping;
+
+	mapping = kzalloc(sizeof(struct mapping), GFP_KERNEL);
+	if (!mapping)
+		return ERR_PTR(-ENOMEM);
+
+	config_item_init_type_name(&mapping->item, name,
+				   &mapping_type);
+
+	mapping->protocol = 0;
+
+	return &mapping->item;
+}
+
+static void remote_map_release(struct config_item *item)
+{
+	kfree(to_remote_map(item));
+}
+
+static ssize_t remote_map_attr_show(struct config_item *item,
+					 struct configfs_attribute *attr,
+					 char *page)
+{
+	return sprintf(page,
+"Remote map\n"
+"\n"
+"Map for a specific application\n"
+"Remote signals matching this map will be translated into keyboard/mouse events\n");
+}
+
+static struct configfs_item_operations remote_map_item_ops = {
+	.release	= remote_map_release,
+	.show_attribute	= remote_map_attr_show,
+};
+
+/*
+ * Note that, since no extra work is required on ->drop_item(),
+ * no ->drop_item() is provided.
+ */
+static struct configfs_group_operations remote_map_group_ops = {
+	.make_item	= remote_map_make_item,
+};
+
+static struct configfs_attribute remote_map_attr_description = {
+	.ca_owner = THIS_MODULE,
+	.ca_name = "description",
+	.ca_mode = S_IRUGO,
+};
+
+static struct configfs_attribute *remote_map_attrs[] = {
+	&remote_map_attr_description,
+	NULL,
+};
+
+static struct config_item_type remote_map_type = {
+	.ct_item_ops	= &remote_map_item_ops,
+	.ct_group_ops	= &remote_map_group_ops,
+	.ct_attrs	= remote_map_attrs,
+	.ct_owner	= THIS_MODULE,
+};
+
+static struct config_group *remotes_make_group(struct config_group *group, const char *name)
+{
+	struct remote_map *remote_map;
+
+	remote_map = kzalloc(sizeof(*remote_map), GFP_KERNEL);
+	if (!remote_map)
+		return ERR_PTR(-ENOMEM);
+
+	config_group_init_type_name(&remote_map->group, name, &remote_map_type);
+
+	return &remote_map->group;
+}
+
+static struct configfs_attribute remotes_attr_description = {
+	.ca_owner = THIS_MODULE,
+	.ca_name = "description",
+	.ca_mode = S_IRUGO,
+};
+
+static struct configfs_attribute *remotes_attrs[] = {
+	&remotes_attr_description,
+	NULL,
+};
+
+static ssize_t remotes_attr_show(struct config_item *item,
+					struct configfs_attribute *attr,
+					char *page)
+{
+	return sprintf(page,
+"IR Remotes\n"
+"\n"
+"This subsystem allows the creation of IR remote control maps.\n"
+"Maps allow IR signals to be mapped into key strokes or mouse events.\n");
+}
+
+static struct configfs_item_operations remotes_item_ops = {
+	.show_attribute	= remotes_attr_show,
+};
+
+/*
+ * Note that, since no extra work is required on ->drop_item(),
+ * no ->drop_item() is provided.
+ */
+static struct configfs_group_operations remotes_group_ops = {
+	.make_group	= remotes_make_group,
+};
+
+static struct config_item_type remotes_type = {
+	.ct_item_ops	= &remotes_item_ops,
+	.ct_group_ops	= &remotes_group_ops,
+	.ct_attrs	= remotes_attrs,
+	.ct_owner	= THIS_MODULE,
+};
+
+static struct configfs_subsystem remotes = {
+	.su_group = {
+		.cg_item = {
+			.ci_namebuf = "IR-remotes",
+			.ci_type = &remotes_type,
+		},
+	},
+};
+
 static ssize_t ir_raw_show(struct device *dev,
 				 struct device_attribute *attr, char *buf)
 {
@@ -548,51 +756,18 @@ static ssize_t ir_xmitter_store(struct device *dev,
 	return count;
 }
 
-static ssize_t ir_map_show(struct device *dev,
+static ssize_t ir_debug_show(struct device *dev,
 				 struct device_attribute *attr, char *buf)
 {
 	struct ir_device *ir = to_input_dev(dev)->ir;
+	struct config_item *i;
 
-	return sprintf(buf, "%i\n", ir->raw.xmitter);
-}
-
-static ssize_t ir_map_store(struct device *dev,
-				  struct device_attribute *attr,
-				  const char *buf,
-				  size_t count)
-{
-	struct ir_device *ir = to_input_dev(dev)->ir;
-	struct input_dev *input;
-	int ret;
-
-	input = input_allocate_device();
-	if (!input) {
-		ret = -ENOMEM;
-		goto free_mem;
-	}
-	ret = input_ir_create(input, NULL, NULL);
-	if (ret)
-		goto free_input;
+    mutex_lock(&remotes.su_mutex);
 
-	input->id.bustype = BUS_HOST;
-	input->name = "Test Me";
-
-	input->irbit[0] |= BIT_MASK(IR_CAP_RECEIVE_36K);
-	input->irbit[0] |= BIT_MASK(IR_CAP_RECEIVE_38K);
-	input->irbit[0] |= BIT_MASK(IR_CAP_RECEIVE_40K);
-	input->irbit[0] |= BIT_MASK(IR_CAP_RECEIVE_RAW);
-
-	ret = input_register_device(input);
-
-free_mem:
-free_input:
-	return count;
-}
-
-static ssize_t ir_debug_show(struct device *dev,
-				 struct device_attribute *attr, char *buf)
-{
-	struct ir_device *ir = to_input_dev(dev)->ir;
+    list_for_each_entry(i, &remotes.su_group.cg_children, ci_entry) {
+    	printk("item %s\n", i->ci_name);
+    }
+    mutex_unlock(&remotes.su_mutex);
 
 	return sprintf(buf, "%i\n", ir->raw.xmitter);
 }
@@ -611,14 +786,12 @@ static ssize_t ir_debug_store(struct device *dev,
 static DEVICE_ATTR(raw, S_IRUGO | S_IWUSR, ir_raw_show, ir_raw_store);
 static DEVICE_ATTR(carrier, S_IRUGO | S_IWUSR, ir_carrier_show, ir_carrier_store);
 static DEVICE_ATTR(xmitter, S_IRUGO | S_IWUSR, ir_xmitter_show, ir_xmitter_store);
-static DEVICE_ATTR(map, S_IRUGO | S_IWUSR, ir_map_show, ir_map_store);
 static DEVICE_ATTR(debug, S_IRUGO | S_IWUSR, ir_debug_show, ir_debug_store);
 
 static struct attribute *input_ir_attrs[] = {
 		&dev_attr_raw.attr,
 		&dev_attr_carrier.attr,
 		&dev_attr_xmitter.attr,
-		&dev_attr_map.attr,
 		&dev_attr_debug.attr,
 		NULL
 	};
@@ -630,10 +803,25 @@ static struct attribute_group input_ir_group = {
 
 int input_ir_register(struct input_dev *dev)
 {
+	int ret;
+
 	if (!dev->ir)
 		return 0;
 
-    return sysfs_create_group(&dev->dev.kobj, &input_ir_group);
+	config_group_init(&remotes.su_group);
+	mutex_init(&remotes.su_mutex);
+	ret = configfs_register_subsystem(&remotes);
+	if (ret) {
+		printk(KERN_ERR "Error %d while registering configfs %s\n",
+			   ret, remotes.su_group.cg_item.ci_namebuf);
+		goto out_unregister;
+	}
+
+	return sysfs_create_group(&dev->dev.kobj, &input_ir_group);
+
+out_unregister:
+	configfs_unregister_subsystem(&remotes);
+	return ret;
 }
 
 int input_ir_create(struct input_dev *dev, void *private, send_func xmit)
@@ -657,6 +845,7 @@ void input_ir_destroy(struct input_dev *dev)
 		kfree(dev->ir);
 		dev->ir = NULL;
 	}
+	configfs_unregister_subsystem(&remotes);
 }
 EXPORT_SYMBOL_GPL(input_ir_destroy);

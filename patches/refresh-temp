Bottom: cc5b90ace1be83ea0c43e20e7baabce2ee9cb304
Top:    3232b3b67a3b44e9db540dcb60816a18ff7676e7
Author: Jon Smirl <jonsmirl@gmail.com>
Date:   2009-05-13 15:07:58 -0400

Refresh of phytec

---

diff --git a/include/sound/soc-dai.h b/include/sound/soc-dai.h
index 496dc30..352d7ee 100644
--- a/include/sound/soc-dai.h
+++ b/include/sound/soc-dai.h
@@ -79,7 +79,8 @@ struct snd_pcm_substream;
 #define SND_SOC_CLOCK_OUT		1
 
 #define SND_SOC_STD_AC97_FMTS (SNDRV_PCM_FMTBIT_S16_LE |\
-                               SNDRV_PCM_FMTBIT_S32_LE)
+                               SNDRV_PCM_FMTBIT_S32_LE |\
+                               SNDRV_PCM_FMTBIT_S32_BE)
 
 struct snd_soc_dai_ops;
 struct snd_soc_dai;
diff --git a/sound/soc/fsl/pcm030-audio-fabric.c b/sound/soc/fsl/pcm030-audio-fabric.c
new file mode 100644
index 0000000..ced8929
--- /dev/null
+++ b/sound/soc/fsl/pcm030-audio-fabric.c
@@ -0,0 +1,249 @@
+/*
+ * pcm030 driver for the PSC of the Freescale MPC52xx configured as AC97 interface
+ *
+ * Copyright 2008 Jon Smirl, Digispeaker
+ * Author: Jon Smirl <jonsmirl@gmail.com>
+ *
+ * This file is licensed under the terms of the GNU General Public License
+ * version 2. This program is licensed "as is" without any warranty of any
+ * kind, whether express or implied.
+ */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/interrupt.h>
+#include <linux/device.h>
+#include <linux/delay.h>
+#include <linux/of_device.h>
+#include <linux/of_platform.h>
+#include <linux/dma-mapping.h>
+
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/initval.h>
+#include <sound/soc.h>
+#include <sound/soc-of-simple.h>
+
+#include "mpc5200_dma.h"
+#include "mpc5200_psc_ac97.h"
+#include "../codecs/wm9712.h"
+
+#define PCM030_HP        0
+#define PCM030_MIC_INT   1
+#define PCM030_HEADSET   2
+#define PCM030_HP_OFF    3
+#define PCM030_SPK_ON    0
+#define PCM030_SPK_OFF   1
+
+#define DRV_NAME "pcm030-psc-ac97"
+
+#if 0
+
+static int pcm030_jack_func;
+static int pcm030_spk_func;
+
+static void pcm030_ext_control(struct snd_soc_codec *codec)
+{
+	/* set up jack connection */
+	switch (pcm030_jack_func) {
+	case PCM030_HP:
+		//snd_soc_dapm_disable_pin(codec, "Headset Jack");
+		snd_soc_dapm_disable_pin(codec, "Mic (Internal)");
+		snd_soc_dapm_enable_pin(codec, "Headphone Jack");
+		break;
+	case PCM030_MIC_INT:
+		snd_soc_dapm_disable_pin(codec, "Headset Jack");
+		snd_soc_dapm_disable_pin(codec, "Headphone Jack");
+		snd_soc_dapm_enable_pin(codec, "Mic (Internal)");
+		break;
+	case PCM030_HEADSET:
+		snd_soc_dapm_disable_pin(codec, "Headphone Jack");
+		snd_soc_dapm_disable_pin(codec, "Mic (Internal)");
+		snd_soc_dapm_enable_pin(codec, "Headset Jack");
+		break;
+	}
+
+	if (pcm030_spk_func == PCM030_SPK_ON)
+		snd_soc_dapm_enable_pin(codec, "Speaker");
+	else
+		snd_soc_dapm_disable_pin(codec, "Speaker");
+
+	snd_soc_dapm_sync(codec);
+}
+
+static int pcm030_get_jack(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	ucontrol->value.integer.value[0] = pcm030_jack_func;
+	return 0;
+}
+
+static int pcm030_set_jack(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_codec *codec =  snd_kcontrol_chip(kcontrol);
+
+	if (pcm030_jack_func == ucontrol->value.integer.value[0])
+		return 0;
+
+	pcm030_jack_func = ucontrol->value.integer.value[0];
+	pcm030_ext_control(codec);
+	return 1;
+}
+
+static int pcm030_get_spk(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	ucontrol->value.integer.value[0] = pcm030_spk_func;
+	return 0;
+}
+
+static int pcm030_set_spk(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_codec *codec =  snd_kcontrol_chip(kcontrol);
+
+	if (pcm030_spk_func == ucontrol->value.integer.value[0])
+		return 0;
+
+	pcm030_spk_func = ucontrol->value.integer.value[0];
+	pcm030_ext_control(codec);
+	return 1;
+}
+
+/* pcm030 dapm event handlers */
+static int pcm030_hp_event(struct snd_soc_dapm_widget *w,
+								struct snd_kcontrol *k, int event)
+{
+	//if (SND_SOC_DAPM_EVENT_ON(event))
+	//	set_tc6393_gpio(&tc6393_device.dev,PCM030_TC6393_L_MUTE);
+	//else
+	//	reset_tc6393_gpio(&tc6393_device.dev,PCM030_TC6393_L_MUTE);
+	return 0;
+}
+
+/* pcm030 codec dapm widgets */
+static const struct snd_soc_dapm_widget pcm030_dapm_widgets[] = {
+	SND_SOC_DAPM_HP("Headphone Jack", pcm030_hp_event),
+	SND_SOC_DAPM_HP("Headset Jack", NULL),
+	SND_SOC_DAPM_MIC("Mic (Internal)", NULL),
+	SND_SOC_DAPM_SPK("Speaker", NULL),
+};
+
+/* pcm030 audio map */
+static const struct snd_soc_dapm_route audio_map[] = {
+
+	/* headphone connected to HPOUTL, HPOUTR */
+	{"Headphone Jack", NULL, "HPOUTL"},
+	{"Headphone Jack", NULL, "HPOUTR"},
+
+	/* ext speaker connected to LOUT2, ROUT2 */
+	{"Speaker", NULL, "LOUT2"},
+	{"Speaker", NULL, "ROUT2"},
+
+	/* internal mic is connected to mic1, mic2 differential - with bias */
+	{"MIC1", NULL, "Mic Bias"},
+	{"MIC2", NULL, "Mic Bias"},
+	{"Mic Bias", NULL, "Mic (Internal)"},
+
+	/* headset is connected to HPOUTR, and LINEINR with bias */
+	{"Headset Jack", NULL, "HPOUTR"},
+	{"LINEINR", NULL, "Mic Bias"},
+	{"Mic Bias", NULL, "Headset Jack"},
+
+	{NULL, NULL, NULL},
+};
+
+static const char *jack_function[] = {"Headphone", "Mic", "Line", "Headset", "Off"};
+static const char *spk_function[] = {"On", "Off"};
+static const struct soc_enum pcm030_enum[] = {
+	SOC_ENUM_SINGLE_EXT(5, jack_function),
+	SOC_ENUM_SINGLE_EXT(2, spk_function),
+};
+
+static const struct snd_kcontrol_new pcm030_controls[] = {
+	SOC_ENUM_EXT("Jack Function", pcm030_enum[0], pcm030_get_jack,
+		pcm030_set_jack),
+	SOC_ENUM_EXT("Speaker Function", pcm030_enum[1], pcm030_get_spk,
+		pcm030_set_spk),
+};
+
+static int pcm030_init(struct snd_soc_codec *codec)
+{
+
+	/* set up pcm030 codec pins */
+	snd_soc_dapm_disable_pin(codec, "OUT3");
+	snd_soc_dapm_disable_pin(codec, "MONOOUT");
+
+	snd_soc_dapm_new_controls(codec, pcm030_dapm_widgets,
+					ARRAY_SIZE(pcm030_dapm_widgets));
+
+	snd_soc_dapm_add_routes(codec, audio_map, ARRAY_SIZE(audio_map));
+	snd_soc_dapm_sync(codec);
+
+	return 0;
+}
+
+#else
+static int pcm030_init(struct snd_soc_codec *codec)
+{
+	return 0;
+}
+#endif
+
+/*
+ * This is an example codec initialization for a wm9712 connected to a
+ * mpc5200. It is missing logic to detect hp/mic insertions and logic
+ * to re-route the audio in such an event.
+ */
+static int pcm030_wm9712_probe(struct platform_device *pdev)
+{
+	of_snd_soc_register_fabric("pcm030", NULL, pcm030_init);
+	return 0;
+}
+
+#ifdef CONFIG_PM
+
+static int pcm030_wm9712_suspend(struct platform_device *pdev,
+	pm_message_t state)
+{
+	return 0;
+}
+
+static int pcm030_wm9712_resume(struct platform_device *pdev)
+{
+	return 0;
+}
+
+#else
+#define pcm030_wm9712_suspend NULL
+#define pcm030_wm9712_resume  NULL
+#endif
+
+static struct platform_driver pcm030_fabric = {
+	.probe	= pcm030_wm9712_probe,
+	.suspend = pcm030_wm9712_suspend,
+ 	.resume = pcm030_wm9712_resume,
+	.driver	= {
+		.name	= "pcm030-audio-fabric",
+	},
+};
+
+static __init int pcm030_fabric_init(void)
+{
+	return platform_driver_register(&pcm030_fabric);
+}
+
+static __exit void pcm030_fabric_exit(void)
+{
+}
+
+module_init(pcm030_fabric_init);
+module_exit(pcm030_fabric_exit);
+
+
+MODULE_AUTHOR("Jon Smirl <jonsmirl@gmail.com>");
+MODULE_DESCRIPTION(DRV_NAME ": mpc5200 pcm030 fabric driver");
+MODULE_LICENSE("GPL");
+

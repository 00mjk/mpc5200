Bottom: a6a0f4ee5844a7a498e89122ec16466b6b31a58d
Top:    1c9ca8901686be20a7b4f919804aedb8312f894a
Author: Jon Smirl <jonsmirl@gmail.com>
Date:   2008-10-30 15:12:07 -0400

Refresh of jds-lirc

---

diff --git a/drivers/input/Makefile b/drivers/input/Makefile
index da47340..00b3039 100644
--- a/drivers/input/Makefile
+++ b/drivers/input/Makefile
@@ -5,7 +5,7 @@
 # Each configuration option enables a list of files.
 
 obj-$(CONFIG_INPUT)		+= input-core.o
-input-core-objs := input.o ff-core.o ir-core.o
+input-core-objs := input.o ff-core.o ir-core.o ir-configfs.o
 
 obj-$(CONFIG_INPUT_FF_MEMLESS)	+= ff-memless.o
 obj-$(CONFIG_INPUT_POLLDEV)	+= input-polldev.o
diff --git a/drivers/input/ir-configfs.c b/drivers/input/ir-configfs.c
new file mode 100644
index 0000000..5017186
--- /dev/null
+++ b/drivers/input/ir-configfs.c
@@ -0,0 +1,218 @@
+/*
+ * Configfs routines for IR support
+ *
+ * Copyright (C) 2008 Jon Smirl <jonsmirl@gmail.com>
+ */
+
+#include <linux/kernel.h>
+#include <linux/device.h>
+#include <linux/input.h>
+
+#include "ir.h"
+
+struct mapping {
+	struct config_item item;
+	int protocol;
+	int device;
+	int command;
+};
+
+static inline struct mapping *to_mapping(struct config_item *item)
+{
+	return item ? container_of(item, struct mapping, item) : NULL;
+}
+
+static void mapping_release(struct config_item *item)
+{
+	kfree(to_mapping(item));
+}
+
+static ssize_t mapping_attr_show(struct config_item *item,
+				      struct configfs_attribute *attr,
+				      char *page)
+{
+	ssize_t count;
+	struct mapping *mapping = to_mapping(item);
+
+	count = sprintf(page, "%d\n", mapping->protocol);
+
+	return count;
+}
+
+static ssize_t mapping_attr_store(struct config_item *item,
+				       struct configfs_attribute *attr,
+				       const char *page, size_t count)
+{
+	struct mapping *mapping = to_mapping(item);
+	unsigned long tmp;
+	char *p = (char *) page;
+
+	tmp = simple_strtoul(p, &p, 10);
+	if (!p || (*p && (*p != '\n')))
+		return -EINVAL;
+
+	if (tmp > INT_MAX)
+		return -ERANGE;
+
+	mapping->protocol = tmp;
+
+	return count;
+}
+
+static struct configfs_item_operations mapping_item_ops = {
+	.release		= mapping_release,
+	.show_attribute		= mapping_attr_show,
+	.store_attribute	= mapping_attr_store,
+};
+
+static struct configfs_attribute mapping_attr_protocol = {
+	.ca_owner = THIS_MODULE,
+	.ca_name = "protocol",
+	.ca_mode = S_IRUGO | S_IWUSR,
+};
+
+static struct configfs_attribute *mapping_attrs[] = {
+	&mapping_attr_protocol,
+	NULL,
+};
+
+static struct config_item_type mapping_type = {
+	.ct_item_ops	= &mapping_item_ops,
+	.ct_attrs	= mapping_attrs,
+	.ct_owner	= THIS_MODULE,
+};
+
+struct remote_map {
+	struct config_group group;
+};
+
+static inline struct remote_map *to_remote_map(struct config_item *item)
+{
+	return item ? container_of(to_config_group(item), struct remote_map, group) : NULL;
+}
+
+static struct config_item *remote_map_make_item(struct config_group *group, const char *name)
+{
+	struct mapping *mapping;
+
+	mapping = kzalloc(sizeof(struct mapping), GFP_KERNEL);
+	if (!mapping)
+		return ERR_PTR(-ENOMEM);
+
+	config_item_init_type_name(&mapping->item, name,
+				   &mapping_type);
+
+	mapping->protocol = 0;
+
+	return &mapping->item;
+}
+
+static void remote_map_release(struct config_item *item)
+{
+	kfree(to_remote_map(item));
+}
+
+static ssize_t remote_map_attr_show(struct config_item *item,
+					 struct configfs_attribute *attr,
+					 char *page)
+{
+	return sprintf(page,
+"Remote map\n"
+"\n"
+"Map for a specific application\n"
+"Remote signals matching this map will be translated into keyboard/mouse events\n");
+}
+
+static struct configfs_item_operations remote_map_item_ops = {
+	.release	= remote_map_release,
+	.show_attribute	= remote_map_attr_show,
+};
+
+/*
+ * Note that, since no extra work is required on ->drop_item(),
+ * no ->drop_item() is provided.
+ */
+static struct configfs_group_operations remote_map_group_ops = {
+	.make_item	= remote_map_make_item,
+};
+
+static struct configfs_attribute remote_map_attr_description = {
+	.ca_owner = THIS_MODULE,
+	.ca_name = "description",
+	.ca_mode = S_IRUGO,
+};
+
+static struct configfs_attribute *remote_map_attrs[] = {
+	&remote_map_attr_description,
+	NULL,
+};
+
+static struct config_item_type remote_map_type = {
+	.ct_item_ops	= &remote_map_item_ops,
+	.ct_group_ops	= &remote_map_group_ops,
+	.ct_attrs	= remote_map_attrs,
+	.ct_owner	= THIS_MODULE,
+};
+
+static struct config_group *remotes_make_group(struct config_group *group, const char *name)
+{
+	struct remote_map *remote_map;
+
+	remote_map = kzalloc(sizeof(*remote_map), GFP_KERNEL);
+	if (!remote_map)
+		return ERR_PTR(-ENOMEM);
+
+	config_group_init_type_name(&remote_map->group, name, &remote_map_type);
+
+	return &remote_map->group;
+}
+
+static struct configfs_attribute remotes_attr_description = {
+	.ca_owner = THIS_MODULE,
+	.ca_name = "description",
+	.ca_mode = S_IRUGO,
+};
+
+static struct configfs_attribute *remotes_attrs[] = {
+	&remotes_attr_description,
+	NULL,
+};
+
+static ssize_t remotes_attr_show(struct config_item *item,
+					struct configfs_attribute *attr,
+					char *page)
+{
+	return sprintf(page,
+"IR Remotes\n"
+"\n"
+"This subsystem allows the creation of IR remote control maps.\n"
+"Maps allow IR signals to be mapped into key strokes or mouse events.\n");
+}
+
+static struct configfs_item_operations remotes_item_ops = {
+	.show_attribute	= remotes_attr_show,
+};
+
+/*
+ * Note that, since no extra work is required on ->drop_item(),
+ * no ->drop_item() is provided.
+ */
+static struct configfs_group_operations remotes_group_ops = {
+	.make_group	= remotes_make_group,
+};
+
+static struct config_item_type remotes_type = {
+	.ct_item_ops	= &remotes_item_ops,
+	.ct_group_ops	= &remotes_group_ops,
+	.ct_attrs	= remotes_attrs,
+	.ct_owner	= THIS_MODULE,
+};
+
+struct configfs_subsystem remotes = {
+	.su_group = {
+		.cg_item = {
+			.ci_namebuf = "IR-remotes",
+			.ci_type = &remotes_type,
+		},
+	},
+};
diff --git a/drivers/input/ir-core.c b/drivers/input/ir-core.c
index 2ff3e2c..3c8f412 100644
--- a/drivers/input/ir-core.c
+++ b/drivers/input/ir-core.c
@@ -7,16 +7,8 @@
 #include <linux/kernel.h>
 #include <linux/device.h>
 #include <linux/input.h>
-#include <linux/configfs.h>
 
-#undef IR_PROTOCOL_DEBUG
-#ifdef IR_PROTOCOL_DEBUG
-#define PDEBUG( format, arg... ) \
-	printk(KERN_DEBUG format , ## arg);
-#else
-#define PDEBUG(format, arg...) \
-	({ if (0) printk(KERN_DEBUG format , ## arg); 0; })
-#endif
+#include "ir.h"
 
 static int encode_sony(struct ir_device *ir, struct ir_command *command)
 {
@@ -460,213 +452,6 @@ void input_ir_decode(struct input_dev *dev, unsigned int delta, unsigned int bit
 }
 EXPORT_SYMBOL_GPL(input_ir_decode);
 
-struct mapping {
-	struct config_item item;
-	int protocol;
-	int device;
-	int command;
-};
-
-static inline struct mapping *to_mapping(struct config_item *item)
-{
-	return item ? container_of(item, struct mapping, item) : NULL;
-}
-
-static void mapping_release(struct config_item *item)
-{
-	kfree(to_mapping(item));
-}
-
-static ssize_t mapping_attr_show(struct config_item *item,
-				      struct configfs_attribute *attr,
-				      char *page)
-{
-	ssize_t count;
-	struct mapping *mapping = to_mapping(item);
-
-	count = sprintf(page, "%d\n", mapping->protocol);
-
-	return count;
-}
-
-static ssize_t mapping_attr_store(struct config_item *item,
-				       struct configfs_attribute *attr,
-				       const char *page, size_t count)
-{
-	struct mapping *mapping = to_mapping(item);
-	unsigned long tmp;
-	char *p = (char *) page;
-
-	tmp = simple_strtoul(p, &p, 10);
-	if (!p || (*p && (*p != '\n')))
-		return -EINVAL;
-
-	if (tmp > INT_MAX)
-		return -ERANGE;
-
-	mapping->protocol = tmp;
-
-	return count;
-}
-
-static struct configfs_item_operations mapping_item_ops = {
-	.release		= mapping_release,
-	.show_attribute		= mapping_attr_show,
-	.store_attribute	= mapping_attr_store,
-};
-
-static struct configfs_attribute mapping_attr_protocol = {
-	.ca_owner = THIS_MODULE,
-	.ca_name = "protocol",
-	.ca_mode = S_IRUGO | S_IWUSR,
-};
-
-static struct configfs_attribute *mapping_attrs[] = {
-	&mapping_attr_protocol,
-	NULL,
-};
-
-static struct config_item_type mapping_type = {
-	.ct_item_ops	= &mapping_item_ops,
-	.ct_attrs	= mapping_attrs,
-	.ct_owner	= THIS_MODULE,
-};
-
-struct remote_map {
-	struct config_group group;
-};
-
-static inline struct remote_map *to_remote_map(struct config_item *item)
-{
-	return item ? container_of(to_config_group(item), struct remote_map, group) : NULL;
-}
-
-static struct config_item *remote_map_make_item(struct config_group *group, const char *name)
-{
-	struct mapping *mapping;
-
-	mapping = kzalloc(sizeof(struct mapping), GFP_KERNEL);
-	if (!mapping)
-		return ERR_PTR(-ENOMEM);
-
-	config_item_init_type_name(&mapping->item, name,
-				   &mapping_type);
-
-	mapping->protocol = 0;
-
-	return &mapping->item;
-}
-
-static void remote_map_release(struct config_item *item)
-{
-	kfree(to_remote_map(item));
-}
-
-static ssize_t remote_map_attr_show(struct config_item *item,
-					 struct configfs_attribute *attr,
-					 char *page)
-{
-	return sprintf(page,
-"Remote map\n"
-"\n"
-"Map for a specific application\n"
-"Remote signals matching this map will be translated into keyboard/mouse events\n");
-}
-
-static struct configfs_item_operations remote_map_item_ops = {
-	.release	= remote_map_release,
-	.show_attribute	= remote_map_attr_show,
-};
-
-/*
- * Note that, since no extra work is required on ->drop_item(),
- * no ->drop_item() is provided.
- */
-static struct configfs_group_operations remote_map_group_ops = {
-	.make_item	= remote_map_make_item,
-};
-
-static struct configfs_attribute remote_map_attr_description = {
-	.ca_owner = THIS_MODULE,
-	.ca_name = "description",
-	.ca_mode = S_IRUGO,
-};
-
-static struct configfs_attribute *remote_map_attrs[] = {
-	&remote_map_attr_description,
-	NULL,
-};
-
-static struct config_item_type remote_map_type = {
-	.ct_item_ops	= &remote_map_item_ops,
-	.ct_group_ops	= &remote_map_group_ops,
-	.ct_attrs	= remote_map_attrs,
-	.ct_owner	= THIS_MODULE,
-};
-
-static struct config_group *remotes_make_group(struct config_group *group, const char *name)
-{
-	struct remote_map *remote_map;
-
-	remote_map = kzalloc(sizeof(*remote_map), GFP_KERNEL);
-	if (!remote_map)
-		return ERR_PTR(-ENOMEM);
-
-	config_group_init_type_name(&remote_map->group, name, &remote_map_type);
-
-	return &remote_map->group;
-}
-
-static struct configfs_attribute remotes_attr_description = {
-	.ca_owner = THIS_MODULE,
-	.ca_name = "description",
-	.ca_mode = S_IRUGO,
-};
-
-static struct configfs_attribute *remotes_attrs[] = {
-	&remotes_attr_description,
-	NULL,
-};
-
-static ssize_t remotes_attr_show(struct config_item *item,
-					struct configfs_attribute *attr,
-					char *page)
-{
-	return sprintf(page,
-"IR Remotes\n"
-"\n"
-"This subsystem allows the creation of IR remote control maps.\n"
-"Maps allow IR signals to be mapped into key strokes or mouse events.\n");
-}
-
-static struct configfs_item_operations remotes_item_ops = {
-	.show_attribute	= remotes_attr_show,
-};
-
-/*
- * Note that, since no extra work is required on ->drop_item(),
- * no ->drop_item() is provided.
- */
-static struct configfs_group_operations remotes_group_ops = {
-	.make_group	= remotes_make_group,
-};
-
-static struct config_item_type remotes_type = {
-	.ct_item_ops	= &remotes_item_ops,
-	.ct_group_ops	= &remotes_group_ops,
-	.ct_attrs	= remotes_attrs,
-	.ct_owner	= THIS_MODULE,
-};
-
-static struct configfs_subsystem remotes = {
-	.su_group = {
-		.cg_item = {
-			.ci_namebuf = "IR-remotes",
-			.ci_type = &remotes_type,
-		},
-	},
-};
-
 static ssize_t ir_raw_show(struct device *dev,
 				 struct device_attribute *attr, char *buf)
 {
diff --git a/drivers/input/ir.h b/drivers/input/ir.h
new file mode 100644
index 0000000..26f48ba
--- /dev/null
+++ b/drivers/input/ir.h
@@ -0,0 +1,46 @@
+/*
+ * Private defines for IR support
+ *
+ * Copyright (C) 2008 Jon Smirl <jonsmirl@gmail.com>
+ */
+
+#include <linux/configfs.h>
+
+#undef IR_PROTOCOL_DEBUG
+#ifdef IR_PROTOCOL_DEBUG
+#define PDEBUG( format, arg... ) \
+	printk(KERN_DEBUG format , ## arg);
+#else
+#define PDEBUG(format, arg...) \
+	({ if (0) printk(KERN_DEBUG format , ## arg); 0; })
+#endif
+
+struct ir_protocol {
+	unsigned int state, code, good, count, bits, mode;
+};
+
+struct ir_device {
+	struct ir_protocol sony;
+	struct ir_protocol jvc;
+	struct ir_protocol nec;
+	struct ir_protocol rc5;
+	struct ir_protocol rc6;
+	struct mutex lock;
+	void *private;
+	send_func xmit;
+	struct {
+		unsigned int buffer[200];
+		unsigned int count;
+	} send;
+	struct {
+		int buffer[200];
+		unsigned int head;
+		unsigned int tail;
+		unsigned int carrier;
+		unsigned int xmitter;
+	} raw;
+};
+
+extern struct configfs_subsystem remotes;
+
+
diff --git a/include/linux/input.h b/include/linux/input.h
index 5f2e50d..edc824b 100644
--- a/include/linux/input.h
+++ b/include/linux/input.h
@@ -1440,38 +1440,12 @@ int input_ff_create_memless(struct input_dev *dev, void *data,
 		int (*play_effect)(struct input_dev *, void *, struct ff_effect *));
 
 /**
- * struct ir_device - IR support structures
+ * struct ir_device - IR support functions
  */
 
-struct ir_protocol {
-	unsigned int state, code, good, count, bits, mode;
-};
-
 typedef int (*send_func)(void *private, unsigned int *buffer, unsigned int count,
 		unsigned int frequency, unsigned int xmitters);
 
-struct ir_device {
-	struct ir_protocol sony;
-	struct ir_protocol jvc;
-	struct ir_protocol nec;
-	struct ir_protocol rc5;
-	struct ir_protocol rc6;
-	struct mutex lock;
-	void *private;
-	send_func xmit;
-	struct {
-		unsigned int buffer[200];
-		unsigned int count;
-	} send;
-	struct {
-		int buffer[200];
-		unsigned int head;
-		unsigned int tail;
-		unsigned int carrier;
-		unsigned int xmitter;
-	} raw;
-};
-
 int input_ir_create(struct input_dev *dev, void *private, send_func send);
 void input_ir_destroy(struct input_dev *dev);

Bottom: 8d8a4151ae69abe3400e70be16efbd8fe0e39eaf
Top:    911c7646099998b5ef6d306a1fb2f39020534ab9
Author: Jon Smirl <jonsmirl@gmail.com>
Date:   2009-04-20 11:59:29 -0400

Refresh of efika-audio

---

diff --git a/include/sound/soc-of-simple.h b/include/sound/soc-of-simple.h
index 61d3c29..dc979be 100644
--- a/include/sound/soc-of-simple.h
+++ b/include/sound/soc-of-simple.h
@@ -12,20 +12,16 @@
 #include <linux/of.h>
 #include <sound/soc.h>
 
-#define SOC_OF_SIMPLE_MAX_DAI 2
-
 int of_snd_soc_register_codec(struct snd_soc_codec_device *codec_dev,
 			      void *codec_data, struct snd_soc_dai *dai,
-			      int count, struct device_node *node);
-
-int of_snd_soc_register_cpu_dai(struct device_node *node,
-				 struct snd_soc_dai *cpu_dai, int count);
+			      struct device_node *node);
 
-int of_snd_soc_register_platform(struct snd_soc_platform *platform);
-
-int of_snd_soc_register_fabric(char *name, struct snd_soc_ops *ops,
-								int (*init)(struct snd_soc_codec *codec));
+int of_snd_soc_register_platform(struct snd_soc_platform *platform,
+				 struct device_node *node,
+				 struct snd_soc_dai *cpu_dai);
 
 #endif
 
+void of_snd_soc_register_machine(char *name, struct snd_soc_ops *ops);
+
 #endif /* _INCLUDE_SOC_OF_H_ */
diff --git a/sound/soc/fsl/soc-of-simple.c b/sound/soc/fsl/soc-of-simple.c
index 2b32f64..2d0ca0b 100644
--- a/sound/soc/fsl/soc-of-simple.c
+++ b/sound/soc/fsl/soc-of-simple.c
@@ -32,23 +32,18 @@ struct of_snd_soc_device {
 	struct list_head list;
 	struct snd_soc_device device;
 	struct snd_soc_card card;
-	struct snd_soc_dai_link dai_link[SOC_OF_SIMPLE_MAX_DAI];
+	struct snd_soc_dai_link dai_link;
 	struct platform_device *pdev;
-	struct device_node *cpu_dai_node;
+	struct device_node *platform_node;
 	struct device_node *codec_node;
 };
 
-/* template values */
-struct snd_soc_platform *template_platform;
-char *template_name;
-struct snd_soc_ops *template_ops;
-int (*template_init)(struct snd_soc_codec *codec);
+static struct snd_soc_ops *machine_ops = NULL;
+static char *machine_name = NULL;
 
 static struct of_snd_soc_device *
 of_snd_soc_get_device(struct device_node *codec_node)
 {
-	int i;
-
 	struct of_snd_soc_device *of_soc;
 
 	list_for_each_entry(of_soc, &of_snd_soc_device_list, list) {
@@ -63,16 +58,10 @@ of_snd_soc_get_device(struct device_node *codec_node)
 	/* Initialize the structure and add it to the global list */
 	of_soc->codec_node = codec_node;
 	of_soc->id = of_snd_soc_next_index++;
-	of_soc->card.dai_link = of_soc->dai_link;
+	of_soc->card.dai_link = &of_soc->dai_link;
+	of_soc->card.num_links = 1;
 	of_soc->device.card = &of_soc->card;
-	of_soc->card.num_links = SOC_OF_SIMPLE_MAX_DAI;
-	for (i = 0; i < SOC_OF_SIMPLE_MAX_DAI; i++) {
-		of_soc->dai_link[i].ops = template_ops;
-		of_soc->dai_link[i].init = template_init;
-	}
-	of_soc->card.name = template_name;
-	of_soc->card.platform = template_platform;
-
+	of_soc->dai_link.ops = machine_ops;
 	list_add(&of_soc->list, &of_snd_soc_device_list);
 
 	return of_soc;
@@ -85,11 +74,10 @@ static void of_snd_soc_register_device(struct of_snd_soc_device *of_soc)
 
 	/* Only register the device if both the codec and platform have
 	 * been registered */
-	if ((!of_soc->device.codec_data) || (!of_soc->cpu_dai_node) ||
-									!of_soc->card.platform || !of_soc->card.name)
+	if ((!of_soc->device.codec_data) || (!of_soc->platform_node) || !machine_name)
 		return;
 
-	pr_info("platform<-->codec match achieved; registering fabric\n");
+	pr_info("platform<-->codec match achieved; registering machine\n");
 
 	pdev = platform_device_alloc("soc-audio", of_soc->id);
 	if (!pdev) {
@@ -112,10 +100,10 @@ static void of_snd_soc_register_device(struct of_snd_soc_device *of_soc)
 
 int of_snd_soc_register_codec(struct snd_soc_codec_device *codec_dev,
 			      void *codec_data, struct snd_soc_dai *dai,
-			      int count, struct device_node *node)
+			      struct device_node *node)
 {
 	struct of_snd_soc_device *of_soc;
-	int i, rc = 0;
+	int rc = 0;
 
 	pr_info("registering ASoC codec driver: %s\n", node->full_name);
 
@@ -129,11 +117,10 @@ int of_snd_soc_register_codec(struct snd_soc_codec_device *codec_dev,
 	/* Store the codec data */
 	of_soc->device.codec_data = codec_data;
 	of_soc->device.codec_dev = codec_dev;
-	of_soc->card.num_links = min(count, of_soc->card.num_links);
-	for (i = 0; i < of_soc->card.num_links; i++) {
-		of_soc->dai_link[i].name = dai[i].name;
-		of_soc->dai_link[i].codec_dai = dai;
-	}
+	of_soc->dai_link.name = (char *)node->name;
+	of_soc->dai_link.stream_name = (char *)node->name;
+	of_soc->dai_link.codec_dai = dai;
+
 	/* Now try to register the SoC device */
 	of_snd_soc_register_device(of_soc);
 
@@ -143,51 +130,21 @@ int of_snd_soc_register_codec(struct snd_soc_codec_device *codec_dev,
 }
 EXPORT_SYMBOL_GPL(of_snd_soc_register_codec);
 
-int of_snd_soc_register_cpu_dai(struct device_node *node,
-				 struct snd_soc_dai *cpu_dai, int count)
+int of_snd_soc_register_platform(struct snd_soc_platform *platform,
+				 struct device_node *node,
+				 struct snd_soc_dai *cpu_dai)
 {
 	struct of_snd_soc_device *of_soc;
 	struct device_node *codec_node;
 	const phandle *handle;
-	int i, len, rc = 0;
+	int len, rc = 0;
 
-	pr_info("registering ASoC CPU DAI driver: %s\n", node->full_name);
+	pr_info("registering ASoC platform driver: %s\n", node->full_name);
 
 	handle = of_get_property(node, "codec-handle", &len);
-	if (handle && len >= sizeof(handle))
-		codec_node = of_find_node_by_phandle(*handle);
-	else {
-		/* Check for the codec child nodes */
-		for_each_child_of_node(node, codec_node) {
-			struct platform_device *pdev;
-			struct dev_archdata dev_ad = {};
-			char name[MODULE_NAME_LEN];
-			const u32 *addr;
-			int len;
-
-			if (of_modalias_node(codec_node, name, sizeof(name)) < 0)
-				continue;
-
-			addr = of_get_property(codec_node, "reg", &len);
-			if (!addr || len < sizeof(int) || *addr > (1 << 10) - 1) {
-				pr_err("invalid codec reg in device tree\n");
-				continue;
-			}
-			request_module("%s", name);
-
-			pdev = platform_device_alloc(name, 0);
-
-			dev_archdata_set_node(&dev_ad, codec_node);
-			pdev->dev.archdata = dev_ad;
-
-			rc = platform_device_add(pdev);
-			if (rc) {
-				platform_device_put(pdev);
-				return rc;
-			}
-			break;
-		}
-	}
+	if (!handle || len < sizeof(handle))
+		return -ENODEV;
+	codec_node = of_find_node_by_phandle(*handle);
 	if (!codec_node)
 		return -ENODEV;
 	pr_info("looking for codec: %s\n", codec_node->full_name);
@@ -199,12 +156,10 @@ int of_snd_soc_register_cpu_dai(struct device_node *node,
 		goto out;
 	}
 
-	of_soc->cpu_dai_node = node;
-	of_soc->card.num_links = min(count, of_soc->card.num_links);
-	for (i = 0; i < of_soc->card.num_links; i++) {
-		of_soc->dai_link[i].stream_name = cpu_dai[i].name;
-		of_soc->dai_link[i].cpu_dai = &cpu_dai[i];
-	}
+	of_soc->platform_node = node;
+	of_soc->dai_link.cpu_dai = cpu_dai;
+	of_soc->card.platform = platform;
+	of_soc->card.name = machine_name;
 
 	/* Now try to register the SoC device */
 	of_snd_soc_register_device(of_soc);
@@ -213,47 +168,20 @@ int of_snd_soc_register_cpu_dai(struct device_node *node,
 	mutex_unlock(&of_snd_soc_mutex);
 	return rc;
 }
-EXPORT_SYMBOL_GPL(of_snd_soc_register_cpu_dai);
-
-int of_snd_soc_register_platform(struct snd_soc_platform *platform)
-{
-	struct of_snd_soc_device *of_soc;
-	int rc = 0;
-
-	pr_info("registering ASoC platform driver: %s\n", platform->name);
-	template_platform = platform;
-
-	mutex_lock(&of_snd_soc_mutex);
-	list_for_each_entry(of_soc, &of_snd_soc_device_list, list) {
-		of_soc->card.platform = platform;
-		of_snd_soc_register_device(of_soc);
-	}
-	mutex_unlock(&of_snd_soc_mutex);
-	return rc;
-}
 EXPORT_SYMBOL_GPL(of_snd_soc_register_platform);
 
-int of_snd_soc_register_fabric(char *name, struct snd_soc_ops *ops,
-								int (*init)(struct snd_soc_codec *codec))
+void of_snd_soc_register_machine(char *name, struct snd_soc_ops *ops)
 {
-	int i;
 	struct of_snd_soc_device *of_soc;
 
-	pr_info("registering ASoC fabric driver: %s\n", name);
-	template_name = name;
-	template_ops = ops;
-	template_init = init;
+	machine_name = name;
+	machine_ops = ops;
 
-	mutex_lock(&of_snd_soc_mutex);
 	list_for_each_entry(of_soc, &of_snd_soc_device_list, list) {
-		for (i = 0; i < SOC_OF_SIMPLE_MAX_DAI; i++) {
-			of_soc->dai_link[i].ops = ops;
-			of_soc->dai_link[i].init = init;
-		}
-		of_soc->card.name = name;
+		of_soc->dai_link.ops = machine_ops;
+		of_soc->card.name = machine_name;
 		of_snd_soc_register_device(of_soc);
 	}
-	mutex_unlock(&of_snd_soc_mutex);
-	return 0;
+
 }
-EXPORT_SYMBOL_GPL(of_snd_soc_register_fabric);
+EXPORT_SYMBOL_GPL(of_snd_soc_register_machine);

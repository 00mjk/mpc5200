Bottom: 71890965149e22e399a5873588bbe46f4f4043a0
Top:    c9e17d8620db66b01693ddf8db69fc71e6bd7cbc
Author: Jon Smirl <jonsmirl@gmail.com>
Date:   2009-05-19 23:53:20 -0400

Temporary holding patch


---

diff --git a/arch/powerpc/include/asm/mpc52xx_psc.h b/arch/powerpc/include/asm/mpc52xx_psc.h
index c323f4f..fb84120 100644
--- a/arch/powerpc/include/asm/mpc52xx_psc.h
+++ b/arch/powerpc/include/asm/mpc52xx_psc.h
@@ -127,6 +127,7 @@
 #define MPC52xx_PSC_SICR_SIM_FIR		(0x6 << 24)
 #define MPC52xx_PSC_SICR_SIM_CODEC_24		(0x7 << 24)
 #define MPC52xx_PSC_SICR_SIM_CODEC_32		(0xf << 24)
+#define MPC52xx_PSC_SICR_AWR			(1 << 30)
 #define MPC52xx_PSC_SICR_GENCLK			(1 << 23)
 #define MPC52xx_PSC_SICR_I2S			(1 << 22)
 #define MPC52xx_PSC_SICR_CLKPOL			(1 << 21)
diff --git a/drivers/spi/mpc52xx_psc_spi.c b/drivers/spi/mpc52xx_psc_spi.c
index 68c77a9..fe0658a 100644
--- a/drivers/spi/mpc52xx_psc_spi.c
+++ b/drivers/spi/mpc52xx_psc_spi.c
@@ -22,6 +22,7 @@
 #include <linux/delay.h>
 #include <linux/spi/spi.h>
 #include <linux/fsl_devices.h>
+#include <linux/of_spi.h>
 
 #include <asm/mpc52xx.h>
 #include <asm/mpc52xx_psc.h>
@@ -370,24 +371,24 @@ static irqreturn_t mpc52xx_psc_spi_isr(int irq, void *dev_id)
 }
 
 /* bus_num is used only for the case dev->platform_data == NULL */
-static int __init mpc52xx_psc_spi_do_probe(struct device *dev, u32 regaddr,
+static int __init mpc52xx_psc_spi_do_probe(struct of_device *op, u32 regaddr,
 				u32 size, unsigned int irq, s16 bus_num)
 {
-	struct fsl_spi_platform_data *pdata = dev->platform_data;
+	struct fsl_spi_platform_data *pdata = op->dev.platform_data;
 	struct mpc52xx_psc_spi *mps;
 	struct spi_master *master;
 	int ret;
 
-	master = spi_alloc_master(dev, sizeof *mps);
+	master = spi_alloc_master(&op->dev, sizeof *mps);
 	if (master == NULL)
 		return -ENOMEM;
 
-	dev_set_drvdata(dev, master);
+	dev_set_drvdata(&op->dev, master);
 	mps = spi_master_get_devdata(master);
 
 	mps->irq = irq;
 	if (pdata == NULL) {
-		dev_warn(dev, "probe called without platform data, no "
+		dev_warn(&op->dev, "probe called without platform data, no "
 				"(de)activate_cs function will be called\n");
 		mps->activate_cs = NULL;
 		mps->deactivate_cs = NULL;
@@ -407,7 +408,7 @@ static int __init mpc52xx_psc_spi_do_probe(struct device *dev, u32 regaddr,
 
 	mps->psc = ioremap(regaddr, size);
 	if (!mps->psc) {
-		dev_err(dev, "could not ioremap I/O port range\n");
+		dev_err(&op->dev, "could not ioremap I/O port range\n");
 		ret = -EFAULT;
 		goto free_master;
 	}
@@ -439,6 +440,8 @@ static int __init mpc52xx_psc_spi_do_probe(struct device *dev, u32 regaddr,
 	if (ret < 0)
 		goto unreg_master;
 
+	of_register_spi_devices(master, op->node);
+
 	return ret;
 
 unreg_master:
@@ -495,7 +498,7 @@ static int __init mpc52xx_psc_spi_of_probe(struct of_device *op,
 		id = *psc_nump + 1;
 	}
 
-	return mpc52xx_psc_spi_do_probe(&op->dev, (u32)regaddr64, (u32)size64,
+	return mpc52xx_psc_spi_do_probe(op, (u32)regaddr64, (u32)size64,
 					irq_of_parse_and_map(op->node, 0), id);
 }
 
diff --git a/sound/soc/fsl/mpc5200_dma.c b/sound/soc/fsl/mpc5200_dma.c
index 2c42f29..220c01f 100644
--- a/sound/soc/fsl/mpc5200_dma.c
+++ b/sound/soc/fsl/mpc5200_dma.c
@@ -271,7 +271,8 @@ static const struct snd_pcm_hardware psc_dma_hardware = {
 	.info = SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_MMAP_VALID |
 		SNDRV_PCM_INFO_INTERLEAVED | SNDRV_PCM_INFO_BLOCK_TRANSFER |
 		SNDRV_PCM_INFO_BATCH,
-	.formats = SNDRV_PCM_FMTBIT_S32_BE,
+	.formats = SNDRV_PCM_FMTBIT_S8 | SNDRV_PCM_FMTBIT_S16_BE |
+		SNDRV_PCM_FMTBIT_S24_BE | SNDRV_PCM_FMTBIT_S32_BE,
 	.rate_min = 8000,
 	.rate_max = 48000,
 	.channels_min = 1,
diff --git a/sound/soc/fsl/mpc5200_psc_ac97.c b/sound/soc/fsl/mpc5200_psc_ac97.c
index 5077294..6230c09 100644
--- a/sound/soc/fsl/mpc5200_psc_ac97.c
+++ b/sound/soc/fsl/mpc5200_psc_ac97.c
@@ -112,20 +112,26 @@ static void psc_ac97_write(struct snd_ac97 *ac97, unsigned short reg, unsigned s
 static void psc_ac97_cold_reset(struct snd_ac97 *ac97)
 {
 	struct psc_dma *psc_dma = ac97->private_data;
+	struct mpc52xx_psc __iomem *regs = psc_dma->psc_regs;
 
 	/* Do a cold reset */
-	out_8(&psc_dma->psc_regs->op1, MPC52xx_PSC_OP_RES);
+	out_8(&regs->op1, MPC52xx_PSC_OP_RES);
 	udelay(10);
-	out_8(&psc_dma->psc_regs->op0, MPC52xx_PSC_OP_RES);
+	out_8(&regs->op0, MPC52xx_PSC_OP_RES);
 	udelay(50);
 
 	/* PSC recover from cold reset (cfr user manual, not sure if useful) */
-	out_be32(&psc_dma->psc_regs->sicr, in_be32(&psc_dma->psc_regs->sicr));
+	out_be32(&regs->sicr, in_be32(&regs->sicr));
 }
 
 static void psc_ac97_warm_reset(struct snd_ac97 *ac97)
 {
-	pr_info("psc_ac97_warm_reset\n");
+	struct psc_dma *psc_dma = ac97->private_data;
+	struct mpc52xx_psc __iomem *regs = psc_dma->psc_regs;
+
+	out_be32(&regs->sicr, psc_dma->sicr | MPC52xx_PSC_SICR_AWR);
+	udelay(3);
+	out_be32(&regs->sicr, psc_dma->sicr);
 }
 
 struct snd_ac97_bus_ops soc_ac97_ops = {
@@ -275,15 +281,13 @@ static struct snd_soc_dai psc_ac97_dai_template[] = {
 		.channels_min   = 1,
 		.channels_max   = 6,
 		.rates          = SNDRV_PCM_RATE_8000_48000,
-		.formats = SNDRV_PCM_FMTBIT_S8 | SNDRV_PCM_FMTBIT_S16_BE |
-			   SNDRV_PCM_FMTBIT_S24_BE | SNDRV_PCM_FMTBIT_S32_BE,
+		.formats = SNDRV_PCM_FMTBIT_S32_BE,
 	},
 	.capture = {
 		.channels_min   = 1,
 		.channels_max   = 2,
 		.rates          = SNDRV_PCM_RATE_8000_48000,
-		.formats = SNDRV_PCM_FMTBIT_S8 | SNDRV_PCM_FMTBIT_S16_BE |
-			   SNDRV_PCM_FMTBIT_S24_BE | SNDRV_PCM_FMTBIT_S32_BE,
+		.formats = SNDRV_PCM_FMTBIT_S32_BE,
 	},
 	.ops = &psc_ac97_analog_ops,
 },
@@ -308,33 +312,64 @@ static struct snd_soc_dai psc_ac97_dai_template[] = {
 static int __devinit psc_ac97_of_probe(struct of_device *op,
 				      const struct of_device_id *match)
 {
-	int rc;
+	int rc, id1, id2, timeout, max_reset;
 	struct psc_dma *psc_dma;
+	struct snd_ac97 ac97;
+	struct mpc52xx_psc __iomem *regs;
 
 	rc = mpc5200_audio_dma_create(op, psc_ac97_dai_template, ARRAY_SIZE(psc_ac97_dai_template));
 	if (rc != 0)
 		return rc;
 
 	psc_dma = dev_get_drvdata(&op->dev);
+	regs = psc_dma->psc_regs;
+	ac97.private_data = psc_dma;
 
 	psc_dma->imr = 0;
 	out_be16(&psc_dma->psc_regs->isr_imr.imr, psc_dma->imr);
 
-	out_8(&psc_dma->psc_regs->op1, MPC52xx_PSC_OP_RES);
-	udelay(10);
-	out_8(&psc_dma->psc_regs->op0, MPC52xx_PSC_OP_RES);
-	udelay(50);
-
 	/* Configure the serial interface mode to AC97 */
 	psc_dma->sicr = MPC52xx_PSC_SICR_SIM_AC97 | MPC52xx_PSC_SICR_ENAC97;
-	out_be32(&psc_dma->psc_regs->sicr, psc_dma->sicr);
+	out_be32(&regs->sicr, psc_dma->sicr);
 
 	/* No slots active */
-	out_be32(&psc_dma->psc_regs->ac97_slots, 0x00000000);
+	out_be32(&regs->ac97_slots, 0x00000000);
+
+	/* AC97 clock is generated by the codec.
+	 * Ensure that it starts ticking after codec reset.
+	 */
+	max_reset = 0;
+reset:
+	if (max_reset++ > 5) {
+		dev_err(&op->dev, "AC97 codec failed to reset\n");
+		mpc5200_audio_dma_destroy(op);
+		return -ENODEV;
+	}
+
+	psc_ac97_cold_reset(&ac97);
+
+	/* first make sure it is low */
+	timeout = 0;
+	while ((in_8(&regs->ipcr_acr.ipcr) & 0x80) != 0) {
+		udelay(1);
+		if (timeout++ > 1000)
+			goto reset;
+	}
+	/* then wait for the transition to high */
+	timeout = 0;
+	while ((in_8(&regs->ipcr_acr.ipcr) & 0x80) == 0) {
+		udelay(1);
+		if (timeout++ > 1000)
+			goto reset;
+	}
+
+	out_8(&regs->command, MPC52xx_PSC_TX_ENABLE | MPC52xx_PSC_RX_ENABLE);
 
 	/* Go */
-	out_8(&psc_dma->psc_regs->command, MPC52xx_PSC_TX_ENABLE);
-	out_8(&psc_dma->psc_regs->command, MPC52xx_PSC_RX_ENABLE);
+	id1 = psc_ac97_read(&ac97, AC97_VENDOR_ID1);
+	id2 = psc_ac97_read(&ac97, AC97_VENDOR_ID2);
+
+	printk("Codec ID is %04x %04x\n", id1, id2);
 
 	return 0;
 }
diff --git a/sound/soc/fsl/mpc5200_psc_i2s.c b/sound/soc/fsl/mpc5200_psc_i2s.c
index 9d92c83..da988ef 100644
--- a/sound/soc/fsl/mpc5200_psc_i2s.c
+++ b/sound/soc/fsl/mpc5200_psc_i2s.c
@@ -49,8 +49,7 @@ MODULE_LICENSE("GPL");
  * PSC_I2S_FORMATS: audio formats supported by the PSC I2S mode
  */
 #define PSC_I2S_FORMATS (SNDRV_PCM_FMTBIT_S8 | SNDRV_PCM_FMTBIT_S16_BE | \
-			 SNDRV_PCM_FMTBIT_S24_BE | SNDRV_PCM_FMTBIT_S24_BE | \
-			 SNDRV_PCM_FMTBIT_S32_BE)
+			 SNDRV_PCM_FMTBIT_S24_BE | SNDRV_PCM_FMTBIT_S32_BE)
 
 
 static int psc_i2s_hw_params(struct snd_pcm_substream *substream,

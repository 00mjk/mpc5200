Bottom: be6b622978740fc42254d09bd8674ddc5c992eb9
Top:    c9e17d8620db66b01693ddf8db69fc71e6bd7cbc
Author: Jon Smirl <jonsmirl@gmail.com>
Date:   2009-05-19 23:53:20 -0400

Temporary holding patch


---

diff --git a/arch/powerpc/boot/dts/dspeak01.dts b/arch/powerpc/boot/dts/dspeak01.dts
index 398a949..5ffa69b 100644
--- a/arch/powerpc/boot/dts/dspeak01.dts
+++ b/arch/powerpc/boot/dts/dspeak01.dts
@@ -157,25 +157,6 @@
 			#gpio-cells = <2>;
 		};
 
-		spi@f00 {
-			#address-cells = <1>;
-			#size-cells = <0>;
-			compatible = "fsl,mpc5200b-spi","fsl,mpc5200-spi";
-			reg = <0xf00 0x20>;
-			interrupts = <0x2 0xd 0x0 0x2 0xe 0x0>;
-			interrupt-parent = <&mpc5200_pic>;
-
-			mmc-slot@0 {
-				compatible = "mmc-spi";
-				reg = <0>;
-				max-speed = <50000000>;
-				/* Unregulated slot. */
-				voltage-range = <3300 3300>;
-				/*gpios = <&sdcsr_pio 1 0   /*  WP */
-				/*		 &sdcsr_pio 0 1>; /* nCD */
-			};
-		};
-
 		usb@1000 {
 			compatible = "fsl,mpc5200b-ohci","fsl,mpc5200-ohci","ohci-be";
 			reg = <0x1000 0xff>;
@@ -230,14 +211,25 @@
 
 		/* PSC5 is ??? */
 
-		serial@2c00 { /* PSC6 in UART mode */
-			device_type = "serial";
-			compatible = "fsl,mpc5200b-psc-uart","fsl,mpc5200-psc-uart";
-			port-number = <1>;
+		spi@2c00 { /* PSC6 in SPI mode */
+			compatible = "fsl,mpc5200-psc-spi";
 			cell-index = <5>;
 			reg = <0x2c00 0x100>;
 			interrupts = <0x2 0x4 0x0>;
 			interrupt-parent = <&mpc5200_pic>;
+
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			mmc-slot@0 {
+				compatible = "mmc-spi-slot";
+				reg = <0>;
+				spi-max-frequency = <50000000>;
+				/* Unregulated slot. */
+				voltage-range = <3300 3300>;
+				/*gpios = <&sdcsr_pio 1 0   /*  WP */
+				/*		 &sdcsr_pio 0 1>; /* nCD */
+			};
 		};
 
 		ethernet@3000 {
diff --git a/arch/powerpc/include/asm/mpc52xx_psc.h b/arch/powerpc/include/asm/mpc52xx_psc.h
index c323f4f..fb84120 100644
--- a/arch/powerpc/include/asm/mpc52xx_psc.h
+++ b/arch/powerpc/include/asm/mpc52xx_psc.h
@@ -127,6 +127,7 @@
 #define MPC52xx_PSC_SICR_SIM_FIR		(0x6 << 24)
 #define MPC52xx_PSC_SICR_SIM_CODEC_24		(0x7 << 24)
 #define MPC52xx_PSC_SICR_SIM_CODEC_32		(0xf << 24)
+#define MPC52xx_PSC_SICR_AWR			(1 << 30)
 #define MPC52xx_PSC_SICR_GENCLK			(1 << 23)
 #define MPC52xx_PSC_SICR_I2S			(1 << 22)
 #define MPC52xx_PSC_SICR_CLKPOL			(1 << 21)
diff --git a/drivers/spi/mpc52xx_psc_spi.c b/drivers/spi/mpc52xx_psc_spi.c
index 68c77a9..fe0658a 100644
--- a/drivers/spi/mpc52xx_psc_spi.c
+++ b/drivers/spi/mpc52xx_psc_spi.c
@@ -22,6 +22,7 @@
 #include <linux/delay.h>
 #include <linux/spi/spi.h>
 #include <linux/fsl_devices.h>
+#include <linux/of_spi.h>
 
 #include <asm/mpc52xx.h>
 #include <asm/mpc52xx_psc.h>
@@ -370,24 +371,24 @@ static irqreturn_t mpc52xx_psc_spi_isr(int irq, void *dev_id)
 }
 
 /* bus_num is used only for the case dev->platform_data == NULL */
-static int __init mpc52xx_psc_spi_do_probe(struct device *dev, u32 regaddr,
+static int __init mpc52xx_psc_spi_do_probe(struct of_device *op, u32 regaddr,
 				u32 size, unsigned int irq, s16 bus_num)
 {
-	struct fsl_spi_platform_data *pdata = dev->platform_data;
+	struct fsl_spi_platform_data *pdata = op->dev.platform_data;
 	struct mpc52xx_psc_spi *mps;
 	struct spi_master *master;
 	int ret;
 
-	master = spi_alloc_master(dev, sizeof *mps);
+	master = spi_alloc_master(&op->dev, sizeof *mps);
 	if (master == NULL)
 		return -ENOMEM;
 
-	dev_set_drvdata(dev, master);
+	dev_set_drvdata(&op->dev, master);
 	mps = spi_master_get_devdata(master);
 
 	mps->irq = irq;
 	if (pdata == NULL) {
-		dev_warn(dev, "probe called without platform data, no "
+		dev_warn(&op->dev, "probe called without platform data, no "
 				"(de)activate_cs function will be called\n");
 		mps->activate_cs = NULL;
 		mps->deactivate_cs = NULL;
@@ -407,7 +408,7 @@ static int __init mpc52xx_psc_spi_do_probe(struct device *dev, u32 regaddr,
 
 	mps->psc = ioremap(regaddr, size);
 	if (!mps->psc) {
-		dev_err(dev, "could not ioremap I/O port range\n");
+		dev_err(&op->dev, "could not ioremap I/O port range\n");
 		ret = -EFAULT;
 		goto free_master;
 	}
@@ -439,6 +440,8 @@ static int __init mpc52xx_psc_spi_do_probe(struct device *dev, u32 regaddr,
 	if (ret < 0)
 		goto unreg_master;
 
+	of_register_spi_devices(master, op->node);
+
 	return ret;
 
 unreg_master:
@@ -495,7 +498,7 @@ static int __init mpc52xx_psc_spi_of_probe(struct of_device *op,
 		id = *psc_nump + 1;
 	}
 
-	return mpc52xx_psc_spi_do_probe(&op->dev, (u32)regaddr64, (u32)size64,
+	return mpc52xx_psc_spi_do_probe(op, (u32)regaddr64, (u32)size64,
 					irq_of_parse_and_map(op->node, 0), id);
 }
 
diff --git a/sound/soc/fsl/mpc5200_psc_ac97.c b/sound/soc/fsl/mpc5200_psc_ac97.c
index e6a77ab..6230c09 100644
--- a/sound/soc/fsl/mpc5200_psc_ac97.c
+++ b/sound/soc/fsl/mpc5200_psc_ac97.c
@@ -112,20 +112,26 @@ static void psc_ac97_write(struct snd_ac97 *ac97, unsigned short reg, unsigned s
 static void psc_ac97_cold_reset(struct snd_ac97 *ac97)
 {
 	struct psc_dma *psc_dma = ac97->private_data;
+	struct mpc52xx_psc __iomem *regs = psc_dma->psc_regs;
 
 	/* Do a cold reset */
-	out_8(&psc_dma->psc_regs->op1, MPC52xx_PSC_OP_RES);
+	out_8(&regs->op1, MPC52xx_PSC_OP_RES);
 	udelay(10);
-	out_8(&psc_dma->psc_regs->op0, MPC52xx_PSC_OP_RES);
+	out_8(&regs->op0, MPC52xx_PSC_OP_RES);
 	udelay(50);
 
 	/* PSC recover from cold reset (cfr user manual, not sure if useful) */
-	out_be32(&psc_dma->psc_regs->sicr, in_be32(&psc_dma->psc_regs->sicr));
+	out_be32(&regs->sicr, in_be32(&regs->sicr));
 }
 
 static void psc_ac97_warm_reset(struct snd_ac97 *ac97)
 {
-	pr_info("psc_ac97_warm_reset\n");
+	struct psc_dma *psc_dma = ac97->private_data;
+	struct mpc52xx_psc __iomem *regs = psc_dma->psc_regs;
+
+	out_be32(&regs->sicr, psc_dma->sicr | MPC52xx_PSC_SICR_AWR);
+	udelay(3);
+	out_be32(&regs->sicr, psc_dma->sicr);
 }
 
 struct snd_ac97_bus_ops soc_ac97_ops = {
@@ -306,33 +312,64 @@ static struct snd_soc_dai psc_ac97_dai_template[] = {
 static int __devinit psc_ac97_of_probe(struct of_device *op,
 				      const struct of_device_id *match)
 {
-	int rc;
+	int rc, id1, id2, timeout, max_reset;
 	struct psc_dma *psc_dma;
+	struct snd_ac97 ac97;
+	struct mpc52xx_psc __iomem *regs;
 
 	rc = mpc5200_audio_dma_create(op, psc_ac97_dai_template, ARRAY_SIZE(psc_ac97_dai_template));
 	if (rc != 0)
 		return rc;
 
 	psc_dma = dev_get_drvdata(&op->dev);
+	regs = psc_dma->psc_regs;
+	ac97.private_data = psc_dma;
 
 	psc_dma->imr = 0;
 	out_be16(&psc_dma->psc_regs->isr_imr.imr, psc_dma->imr);
 
-	out_8(&psc_dma->psc_regs->op1, MPC52xx_PSC_OP_RES);
-	udelay(10);
-	out_8(&psc_dma->psc_regs->op0, MPC52xx_PSC_OP_RES);
-	udelay(50);
-
 	/* Configure the serial interface mode to AC97 */
 	psc_dma->sicr = MPC52xx_PSC_SICR_SIM_AC97 | MPC52xx_PSC_SICR_ENAC97;
-	out_be32(&psc_dma->psc_regs->sicr, psc_dma->sicr);
+	out_be32(&regs->sicr, psc_dma->sicr);
 
 	/* No slots active */
-	out_be32(&psc_dma->psc_regs->ac97_slots, 0x00000000);
+	out_be32(&regs->ac97_slots, 0x00000000);
+
+	/* AC97 clock is generated by the codec.
+	 * Ensure that it starts ticking after codec reset.
+	 */
+	max_reset = 0;
+reset:
+	if (max_reset++ > 5) {
+		dev_err(&op->dev, "AC97 codec failed to reset\n");
+		mpc5200_audio_dma_destroy(op);
+		return -ENODEV;
+	}
+
+	psc_ac97_cold_reset(&ac97);
+
+	/* first make sure it is low */
+	timeout = 0;
+	while ((in_8(&regs->ipcr_acr.ipcr) & 0x80) != 0) {
+		udelay(1);
+		if (timeout++ > 1000)
+			goto reset;
+	}
+	/* then wait for the transition to high */
+	timeout = 0;
+	while ((in_8(&regs->ipcr_acr.ipcr) & 0x80) == 0) {
+		udelay(1);
+		if (timeout++ > 1000)
+			goto reset;
+	}
+
+	out_8(&regs->command, MPC52xx_PSC_TX_ENABLE | MPC52xx_PSC_RX_ENABLE);
 
 	/* Go */
-	out_8(&psc_dma->psc_regs->command, MPC52xx_PSC_TX_ENABLE);
-	out_8(&psc_dma->psc_regs->command, MPC52xx_PSC_RX_ENABLE);
+	id1 = psc_ac97_read(&ac97, AC97_VENDOR_ID1);
+	id2 = psc_ac97_read(&ac97, AC97_VENDOR_ID2);
+
+	printk("Codec ID is %04x %04x\n", id1, id2);
 
 	return 0;
 }

Bottom: 45a6e497b37bcb81ecfc3c8f9aaaff3f3b1bb84b
Top:    f3ede7bfa41513e4b531da09a39e989bd9e6377d
Author: Jon Smirl <jonsmirl@gmail.com>
Date:   2009-05-23 12:06:51 -0400

Temporary holding patch


---

diff --git a/sound/soc/fsl/mpc5200_dma.c b/sound/soc/fsl/mpc5200_dma.c
index 95df860..a9ad54d 100644
--- a/sound/soc/fsl/mpc5200_dma.c
+++ b/sound/soc/fsl/mpc5200_dma.c
@@ -415,7 +415,7 @@ struct snd_soc_platform mpc5200_audio_dma_platform = {
 EXPORT_SYMBOL_GPL(mpc5200_audio_dma_platform);
 
 /* ---------------------------------------------------------------------
- * Sysfs attributes for debugging
+ * Sysfs attributes for error monitoring
  */
 
 static ssize_t psc_dma_status_show(struct device *dev,
@@ -590,7 +590,8 @@ int mpc5200_audio_dma_create(struct of_device *op)
 	if (rc)
 		dev_info(psc_dma->dev, "error creating sysfs files\n");
 
-	return 0;
+	/* Tell the ASoC OF helpers about it */
+	return snd_soc_register_platform(&mpc5200_audio_dma_platform);
 }
 EXPORT_SYMBOL_GPL(mpc5200_audio_dma_create);
 
@@ -600,6 +601,8 @@ int mpc5200_audio_dma_destroy(struct of_device *op)
 
 	dev_dbg(&op->dev, "mpc5200_audio_dma_destroy()\n");
 
+	snd_soc_unregister_platform(&mpc5200_audio_dma_platform);
+
 	bcom_gen_bd_rx_release(psc_dma->capture.bcom_task);
 	bcom_gen_bd_tx_release(psc_dma->playback.bcom_task);
 
@@ -609,7 +612,6 @@ int mpc5200_audio_dma_destroy(struct of_device *op)
 	free_irq(psc_dma->playback.irq, &psc_dma->playback);
 
 	iounmap(psc_dma->psc_regs);
-	iounmap(psc_dma->fifo_regs);
 	kfree(psc_dma);
 	dev_set_drvdata(&op->dev, NULL);
 
@@ -617,19 +619,6 @@ int mpc5200_audio_dma_destroy(struct of_device *op)
 }
 EXPORT_SYMBOL_GPL(mpc5200_audio_dma_destroy);
 
-static int __init mpc5200_soc_platform_init(void)
-{
-	/* Tell the ASoC OF helpers about it */
-	return snd_soc_register_platform(&mpc5200_audio_dma_platform);
-}
-module_init(mpc5200_soc_platform_init);
-
-static void __exit mpc5200_soc_platform_exit(void)
-{
-	snd_soc_unregister_platform(&mpc5200_audio_dma_platform);
-}
-module_exit(mpc5200_soc_platform_exit);
-
 MODULE_AUTHOR("Grant Likely <grant.likely@secretlab.ca>");
 MODULE_DESCRIPTION("Freescale MPC5200 PSC in DMA mode ASoC Driver");
 MODULE_LICENSE("GPL");
diff --git a/sound/soc/fsl/mpc5200_psc_ac97.c b/sound/soc/fsl/mpc5200_psc_ac97.c
index fa1bb9a..56dac55 100644
--- a/sound/soc/fsl/mpc5200_psc_ac97.c
+++ b/sound/soc/fsl/mpc5200_psc_ac97.c
@@ -94,27 +94,61 @@ static void psc_ac97_write(struct snd_ac97 *ac97, unsigned short reg, unsigned s
 	spin_unlock(&psc_dma->lock);
 }
 
-static void psc_ac97_cold_reset(struct snd_ac97 *ac97)
+static void psc_ac97_warm_reset(struct snd_ac97 *ac97)
 {
 	struct mpc52xx_psc __iomem *regs = psc_dma->psc_regs;
 
-	/* Do a cold reset */
-	out_8(&regs->op1, MPC52xx_PSC_OP_RES);
-	udelay(10);
-	out_8(&regs->op0, MPC52xx_PSC_OP_RES);
-	udelay(50);
-
-	/* PSC recover from cold reset (cfr user manual, not sure if useful) */
-	out_be32(&regs->sicr, in_be32(&regs->sicr));
+	out_be32(&regs->sicr, psc_dma->sicr | MPC52xx_PSC_SICR_AWR);
+	udelay(3);
+	out_be32(&regs->sicr, psc_dma->sicr);
 }
 
-static void psc_ac97_warm_reset(struct snd_ac97 *ac97)
+static int psc_ac97_cold_reset_check(struct snd_ac97 *ac97)
 {
+	int max_reset, timeout;
 	struct mpc52xx_psc __iomem *regs = psc_dma->psc_regs;
 
-	out_be32(&regs->sicr, psc_dma->sicr | MPC52xx_PSC_SICR_AWR);
-	udelay(3);
-	out_be32(&regs->sicr, psc_dma->sicr);
+	/* AC97 clock is generated by the codec.
+	 * Ensure that it starts ticking after codec reset.
+	 */
+	for (max_reset = 0; max_reset < 5; max_reset++) {
+
+		/* Do a cold reset */
+		out_8(&regs->op1, MPC52xx_PSC_OP_RES);
+		udelay(10);
+		out_8(&regs->op0, MPC52xx_PSC_OP_RES);
+		udelay(50);
+
+		/* PSC recover from cold reset (cfr user manual, not sure if useful) */
+		out_be32(&regs->sicr, in_be32(&regs->sicr));
+
+		psc_ac97_warm_reset(ac97);
+
+		/* first make sure AC97 clock is low */
+		for (timeout = 0; ((in_8(&regs->ipcr_acr.ipcr) & 0x80) != 0) &&
+				(timeout < 100); timeout++)
+			udelay(10);
+		if (timeout == 100)
+			continue;
+
+		/* then wait for the transition to high */
+		for (timeout = 0; ((in_8(&regs->ipcr_acr.ipcr) & 0x80) == 0) &&
+				(timeout < 100); timeout++)
+			udelay(10);
+		if (timeout == 100)
+			continue;
+
+		break;
+	}
+	if (max_reset == 5)
+		return -ENODEV;
+	return 0;
+}
+
+static void psc_ac97_cold_reset(struct snd_ac97 *ac97)
+{
+	psc_ac97_cold_reset_check(ac97);
+
 }
 
 struct snd_ac97_bus_ops soc_ac97_ops = {
@@ -125,28 +159,11 @@ struct snd_ac97_bus_ops soc_ac97_ops = {
 };
 EXPORT_SYMBOL_GPL(soc_ac97_ops);
 
-#ifdef CONFIG_PM
-static int psc_ac97_suspend(struct snd_soc_dai *dai)
-{
-	return 0;
-}
-
-static int psc_ac97_resume(struct snd_soc_dai *dai)
-{
-	return 0;
-}
-
-#else
-#define psc_ac97_suspend	NULL
-#define psc_ac97_resume	NULL
-#endif
-
 static int psc_ac97_hw_analog_params(struct snd_pcm_substream *substream,
 				 struct snd_pcm_hw_params *params,
-				 struct snd_soc_dai *dai)
+				 struct snd_soc_dai *cpu_dai)
 {
-	struct snd_soc_pcm_runtime *rtd = substream->private_data;
-	struct psc_dma *psc_dma = rtd->dai->cpu_dai->private_data;
+	struct psc_dma *psc_dma = cpu_dai->private_data;
 
 	dev_dbg(psc_dma->dev, "%s(substream=%p) p_size=%i p_bytes=%i"
 		" periods=%i buffer_size=%i  buffer_bytes=%i channels=%i"
@@ -178,10 +195,9 @@ static int psc_ac97_hw_analog_params(struct snd_pcm_substream *substream,
 
 static int psc_ac97_hw_digital_params(struct snd_pcm_substream *substream,
 				 struct snd_pcm_hw_params *params,
-				 struct snd_soc_dai *dai)
+				 struct snd_soc_dai *cpu_dai)
 {
-	struct snd_soc_pcm_runtime *rtd = substream->private_data;
-	struct psc_dma *psc_dma = rtd->dai->cpu_dai->private_data;
+	struct psc_dma *psc_dma = cpu_dai->private_data;
 
 	spin_lock(&psc_dma->lock);
 	if (params_channels(params) == 1)
@@ -194,7 +210,7 @@ static int psc_ac97_hw_digital_params(struct snd_pcm_substream *substream,
 }
 
 static int psc_ac97_trigger(struct snd_pcm_substream *substream, int cmd,
-								 struct snd_soc_dai *dai)
+							struct snd_soc_dai *dai)
 {
 	struct snd_soc_pcm_runtime *rtd = substream->private_data;
 	struct psc_dma *psc_dma = rtd->dai->cpu_dai->private_data;
@@ -236,8 +252,7 @@ static struct snd_soc_dai_ops psc_ac97_digital_ops = {
 struct snd_soc_dai psc_ac97_dai[] = {
 {
 	.name   = "AC97",
-	.suspend = psc_ac97_suspend,
-	.resume = psc_ac97_resume,
+	.ac97_control = 1,
 	.playback = {
 		.channels_min   = 1,
 		.channels_max   = 6,
@@ -254,6 +269,7 @@ struct snd_soc_dai psc_ac97_dai[] = {
 },
 {
 	.name   = "SPDIF",
+	.ac97_control = 1,
 	.playback = {
 		.channels_min   = 1,
 		.channels_max   = 2,
@@ -275,7 +291,7 @@ EXPORT_SYMBOL_GPL(psc_ac97_dai);
 static int __devinit psc_ac97_of_probe(struct of_device *op,
 				      const struct of_device_id *match)
 {
-	int rc, i, id1, id2, timeout, max_reset;
+	int rc, i, id1, id2;
 	struct snd_ac97 ac97;
 	struct mpc52xx_psc __iomem *regs;
 
@@ -288,8 +304,8 @@ static int __devinit psc_ac97_of_probe(struct of_device *op,
 
 	rc = snd_soc_register_dais(psc_ac97_dai, ARRAY_SIZE(psc_ac97_dai));
 	if (rc != 0) {
-		pr_err("Failed to register DAI\n");
-		return 0;
+		dev_err(&op->dev, "Failed to register DAI\n");
+		return rc;
 	}
 
 	psc_dma = dev_get_drvdata(&op->dev);
@@ -312,40 +328,16 @@ static int __devinit psc_ac97_of_probe(struct of_device *op,
 	/* AC97 clock is generated by the codec.
 	 * Ensure that it starts ticking after codec reset.
 	 */
-	max_reset = 0;
-reset:
-	if (max_reset++ > 5) {
+	rc = psc_ac97_cold_reset_check(&ac97);
+	if (rc != 0) {
 		dev_err(&op->dev, "AC97 codec failed to reset\n");
 		mpc5200_audio_dma_destroy(op);
-		return -ENODEV;
-	}
-
-	psc_ac97_cold_reset(&ac97);
-	psc_ac97_warm_reset(&ac97);
-
-	/* first make sure it is low */
-	timeout = 0;
-	while ((in_8(&regs->ipcr_acr.ipcr) & 0x80) != 0) {
-		udelay(1);
-		if (timeout++ > 1000)
-			goto reset;
-	}
-	/* then wait for the transition to high */
-	timeout = 0;
-	while ((in_8(&regs->ipcr_acr.ipcr) & 0x80) == 0) {
-		udelay(1);
-		if (timeout++ > 1000)
-			psc_ac97_warm_reset(&ac97);
+		return rc;
 	}
 
 	/* Go */
 	out_8(&regs->command, MPC52xx_PSC_TX_ENABLE | MPC52xx_PSC_RX_ENABLE);
 
-	id1 = psc_ac97_read(&ac97, AC97_VENDOR_ID1);
-	id2 = psc_ac97_read(&ac97, AC97_VENDOR_ID2);
-
-	dev_info(&op->dev, "Codec ID is %04x %04x\n", id1, id2);
-
 	return 0;
 }
 
diff --git a/sound/soc/fsl/mpc5200_psc_i2s.c b/sound/soc/fsl/mpc5200_psc_i2s.c
index fd70143..f3c1fad 100644
--- a/sound/soc/fsl/mpc5200_psc_i2s.c
+++ b/sound/soc/fsl/mpc5200_psc_i2s.c
@@ -3,6 +3,7 @@
  * ALSA SoC Digital Audio Interface (DAI) driver
  *
  * Copyright (C) 2008 Secret Lab Technologies Ltd.
+ * Copyright (C) 2009 Jon Smirl, Digispeaker
  */
 
 #include <linux/module.h>
@@ -13,8 +14,6 @@
 #include <sound/pcm_params.h>
 #include <sound/soc.h>
 
-#include <sysdev/bestcomm/bestcomm.h>
-#include <sysdev/bestcomm/gen_bd.h>
 #include <asm/time.h>
 #include <asm/mpc52xx.h>
 #include <asm/mpc52xx_psc.h>
diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index bad9d88..cc1e618 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -20,6 +20,8 @@
  *   o Support TDM on PCM and I2S
  */
 
+#define DEBUG
+
 #include <linux/module.h>
 #include <linux/moduleparam.h>
 #include <linux/init.h>
@@ -125,7 +127,7 @@ static int soc_pcm_apply_symmetry(struct snd_pcm_substream *substream)
 
 	if (codec_dai->symmetric_rates || cpu_dai->symmetric_rates ||
 	    machine->symmetric_rates) {
-		dev_dbg(card->dev, "Symmetry forces %dHz rate\n", 
+		dev_dbg(card->dev, "Symmetry forces %dHz rate\n",
 			machine->rate);
 
 		ret = snd_pcm_hw_constraint_minmax(substream->runtime,
diff --git a/sound/soc/soc-dapm.c b/sound/soc/soc-dapm.c
index c1222fa..f3ccbd0 100644
--- a/sound/soc/soc-dapm.c
+++ b/sound/soc/soc-dapm.c
@@ -29,6 +29,8 @@
  *    o Support for reduced codec bias currents.
  */
 
+#define DEBUG
+
 #include <linux/module.h>
 #include <linux/moduleparam.h>
 #include <linux/init.h>

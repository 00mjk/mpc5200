Bottom: 51492627e1b91406e8c50c30f9312318da0346eb
Top:    7c7f6b17cd94d52e452973dc6bd777bd9cb6bf9b
Author: Jon Smirl <jonsmirl@gmail.com>
Date:   2009-05-13 14:12:26 -0400

Temporary holding patch


---

diff --git a/arch/powerpc/boot/dts/dspeak01.dts b/arch/powerpc/boot/dts/dspeak01.dts
index c50e9c6..5b23e9f 100644
--- a/arch/powerpc/boot/dts/dspeak01.dts
+++ b/arch/powerpc/boot/dts/dspeak01.dts
@@ -157,7 +157,7 @@
 			#gpio-cells = <2>;
 		};
 
-		spi@f00 {
+	/*	spi@f00 {
 			#address-cells = <1>;
 			#size-cells = <0>;
 			compatible = "fsl,mpc5200b-spi","fsl,mpc5200-spi";
@@ -168,20 +168,20 @@
 			mmc-slot@0 {
 				compatible = "linux,mmc-spi";
 				reg = <0>;
-				spi-max-frequency = <20000000>;
+				spi-max-frequency = <20000000>; */
 				/* Unregulated slot. */
-				voltage-range = <3300 3300>;
+/*				voltage-range = <3300 3300>; */
 				/*gpios = <&sdcsr_pio 1 0   /*  WP */
 				/*		 &sdcsr_pio 0 1>; /* nCD */
-			};
-		};
+/*			};
+		}; 
 
 		usb@1000 {
 			compatible = "fsl,mpc5200b-ohci","fsl,mpc5200-ohci","ohci-be";
 			reg = <0x1000 0xff>;
 			interrupts = <0x2 0x6 0x0>;
 			interrupt-parent = <&mpc5200_pic>;
-		};
+		};*/
 
 		dma-controller@1200 {
 			device_type = "dma-controller";
@@ -216,7 +216,7 @@
 			codec-handle = <&tas0>;
 		};
 
-		serial@2400 { /* PSC3 in UART mode */
+		serial@2400 {  /* PSC3 in UART mode */ 
 			device_type = "serial";
 			compatible = "fsl,mpc5200b-psc-uart","fsl,mpc5200-psc-uart";
 			port-number = <0>;
@@ -224,21 +224,28 @@
 			reg = <0x2400 0x100>;
 			interrupts = <0x2 0x3 0x0>;
 			interrupt-parent = <&mpc5200_pic>;
-		};
+		}; 
 
-		/* PSC4 is ??? */
+		serial@2600 {		// PSC4
+			compatible = "fsl,mpc5200b-psc-uart","fsl,mpc5200-psc-uart";
+			cell-index = <3>;
+			port-number = <1>;
+			reg = <0x2600 0x100>;
+			interrupts = <0x2 0x11 0x0>;
+			interrupt-parent = <&mpc5200_pic>;
+		};
 
 		/* PSC5 is ??? */
 
-		serial@2c00 { /* PSC6 in UART mode */
-			device_type = "serial";
+	/*	serial@2c00 { *//* PSC6 in UART mode */
+/*			device_type = "serial";
 			compatible = "fsl,mpc5200b-psc-uart","fsl,mpc5200-psc-uart";
 			port-number = <1>;
 			cell-index = <5>;
 			reg = <0x2c00 0x100>;
 			interrupts = <0x2 0x4 0x0>;
 			interrupt-parent = <&mpc5200_pic>;
-		};
+		}; */
 
 		ethernet@3000 {
 			device_type = "network";
@@ -264,13 +271,13 @@
 			};
 		};
 
-		ata@3a00 {
+	/*	ata@3a00 {
 			device_type = "ata";
 			compatible = "fsl,mpc5200b-ata","fsl,mpc5200-ata";
 			reg = <0x3a00 0x100>;
 			interrupts = <0x2 0x7 0x0>;
 			interrupt-parent = <&mpc5200_pic>;
-		};
+		}; */
 
 		i2c@3d00 {
 			#address-cells = <1>;
@@ -323,13 +330,13 @@
 			clock-handle = <&clock0>;
 		};
 
-		ir0@670 { /* General Purpose Timer 6 in Input mode */
+	/*	ir0@670 { */ /* General Purpose Timer 6 in Input mode */ /*
 			compatible = "gpt-ir";
 			cell-index = <7>;
 			reg = <0x670 0x10>;
 			interrupts = <0x1 0x10 0x0>;
 			interrupt-parent = <&mpc5200_pic>;
-		};
+		}; */
 
 		/* This is only an example device to show the usage of gpios. It maps all available
 		 * gpios to the "gpio-provider" device.
diff --git a/arch/powerpc/boot/dts/pcm030.dts b/arch/powerpc/boot/dts/pcm030.dts
index 001c8ef..ee01e92 100644
--- a/arch/powerpc/boot/dts/pcm030.dts
+++ b/arch/powerpc/boot/dts/pcm030.dts
@@ -194,10 +194,10 @@
 			#address-cells = <1>;
 			#size-cells = <0>;
 
-			codec@0 {
+			/*codec@0 {
 				compatible = "wlf,wm9712";
 				reg = <0x0>;
-			};
+			}; */
 		};
 
 		/* PSC2 port is used by CAN1/2 */
diff --git a/sound/soc/fsl/mpc5200_psc_ac97.c b/sound/soc/fsl/mpc5200_psc_ac97.c
index 385f697..aa37c8d 100644
--- a/sound/soc/fsl/mpc5200_psc_ac97.c
+++ b/sound/soc/fsl/mpc5200_psc_ac97.c
@@ -55,7 +55,7 @@ static unsigned short psc_ac97_read(struct snd_ac97 *ac97, unsigned short reg)
 		udelay(10);
 
 	if (!timeout) {
-		printk(KERN_ERR DRV_NAME ": timeout on ac97 bus (rdy)\n");
+		pr_err(timeout on ac97 bus (rdy)\n");
 		return 0xffff;
 	}
 
@@ -69,14 +69,14 @@ static unsigned short psc_ac97_read(struct snd_ac97 *ac97, unsigned short reg)
 		udelay(10);
 
 	if (!timeout) {
-		printk(KERN_ERR DRV_NAME ": timeout on ac97 read (val) %x\n", in_be16(&psc_dma->psc_regs->sr_csr.status));
+		pr_err(timeout on ac97 read (val) %x\n", in_be16(&psc_dma->psc_regs->sr_csr.status));
 		return 0xffff;
 	}
 
 	/* Get the data */
 	val = in_be32(&psc_dma->psc_regs->ac97_data);
 	if ( ((val>>24) & 0x7f) != reg ) {
-		printk(KERN_ERR DRV_NAME ": reg echo error on ac97 read\n");
+		pr_err(reg echo error on ac97 read\n");
 		return 0xffff;
 	}
 	val = (val >> 8) & 0xffff;
@@ -99,7 +99,7 @@ static void psc_ac97_write(struct snd_ac97 *ac97, unsigned short reg, unsigned s
 		udelay(10);
 
 	if (!timeout) {
-		printk(KERN_ERR DRV_NAME ": timeout on ac97 write\n");
+		pr_err(timeout on ac97 write\n");
 		return;
 	}
 
@@ -125,7 +125,7 @@ static void psc_ac97_cold_reset(struct snd_ac97 *ac97)
 
 static void psc_ac97_warm_reset(struct snd_ac97 *ac97)
 {
-	printk("psc_ac97_warm_reset\n");
+	pr_info("psc_ac97_warm_reset\n");
 }
 
 struct snd_ac97_bus_ops soc_ac97_ops = {
@@ -217,7 +217,6 @@ static int psc_ac97_trigger(struct snd_pcm_substream *substream, int cmd,
 		else
 			psc_dma->slots &= 0x0000FFFF;
 
-		printk("Clearing slots %x\n", psc_dma->slots);
 		spin_lock(&psc_dma->lock);
 		out_be32(&psc_dma->psc_regs->ac97_slots, psc_dma->slots);
 		spin_unlock(&psc_dma->lock);

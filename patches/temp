Bottom: 809e8c7f7c2c9efed1a8c36603e9ab500560eaae
Top:    6d9e4df293cc2419a8206ca886b9396426eaa7df
Author: Jon Smirl <jonsmirl@gmail.com>
Date:   2009-05-22 11:28:25 -0400

Temporary holding patch


---

diff --git a/sound/soc/codecs/wm9712.c b/sound/soc/codecs/wm9712.c
index 1fd4e88..49ad987 100644
--- a/sound/soc/codecs/wm9712.c
+++ b/sound/soc/codecs/wm9712.c
@@ -742,6 +742,18 @@ struct snd_soc_codec_device soc_codec_dev_wm9712 = {
 };
 EXPORT_SYMBOL_GPL(soc_codec_dev_wm9712);
 
+static int __init wm9712_modinit(void)
+{
+	return snd_soc_register_dais(wm9712_dai, ARRAY_SIZE(wm9712_dai));
+}
+module_init(wm9712_modinit);
+
+static void __exit wm9712_exit(void)
+{
+	snd_soc_unregister_dais(wm9712_dai, ARRAY_SIZE(wm9712_dai));
+}
+module_exit(wm9712_exit);
+
 MODULE_DESCRIPTION("ASoC WM9711/WM9712 driver");
 MODULE_AUTHOR("Liam Girdwood");
 MODULE_LICENSE("GPL");
diff --git a/sound/soc/fsl/dspeak01_fabric.c b/sound/soc/fsl/dspeak01_fabric.c
index c6c7890..8021d6a 100644
--- a/sound/soc/fsl/dspeak01_fabric.c
+++ b/sound/soc/fsl/dspeak01_fabric.c
@@ -113,7 +113,6 @@ static int __devinit dspeak01_fabric_probe(struct of_device *op,
 	if (!fabric.clock)
 		return -ENODEV;
 
-	of_snd_soc_register_fabric("DSPEAK01", &dspeak01_fabric_ops, NULL);
 	return 0;
 }
 
diff --git a/sound/soc/fsl/efika-audio-fabric.c b/sound/soc/fsl/efika-audio-fabric.c
index 56ae471..13c329f 100644
--- a/sound/soc/fsl/efika-audio-fabric.c
+++ b/sound/soc/fsl/efika-audio-fabric.c
@@ -29,56 +29,57 @@
 #include "mpc5200_psc_ac97.h"
 #include "../codecs/stac9766.h"
 
-static int efika_init(struct snd_soc_codec *codec)
+struct snd_soc_device device;
+struct snd_soc_card card;
+
+static struct snd_soc_dai_link efika_fabric_dai[] = {
 {
-	/* Skeleton driver showing framework for setting
-	 * up board specific fabric drivers.
-	 *
-	 * set up Efika specific controls here
-	 *
-	 * Loading of this driver is trigger by
-	 * platform_device_register_simple("efika-audio-fabric", 0, NULL, 0);
-	 * in arch/powerpc/platforms/52xx/efika.c
-	 */
-	return 0;
-}
+	.name = "AC97",
+	.stream_name = "AC97 Analog",
+	.codec_dai = &stac9766_dai[STAC9766_DAI_AC97_ANALOG],
+	.cpu_dai = &psc_ac97_dai[MPC5200_AC97_NORMAL],
+},
+{
+	.name = "AC97",
+	.stream_name = "AC97 IEC958",
+	.codec_dai = &stac9766_dai[STAC9766_DAI_AC97_DIGITAL],
+	.cpu_dai = &psc_ac97_dai[MPC5200_AC97_SPDIF],
+},
+};
 
-static int efika_stac9766_probe(struct platform_device *pdev)
+static __init int efika_fabric_init(void)
 {
-	of_snd_soc_register_fabric("Efika", NULL, efika_init);
-	return 0;
-}
+	struct platform_device *pdev;
+	int rc;
 
-#ifdef CONFIG_PM
+	if (!machine_is_compatible("bplan,efika"))
+		return -ENODEV;
 
-static int efika_stac9766_suspend(struct platform_device *pdev,
-	pm_message_t state)
-{
-	return 0;
-}
 
-static int efika_stac9766_resume(struct platform_device *pdev)
-{
-	return 0;
-}
+	printk("Initializing Efika audio\n");
+	card.platform = &mpc5200_audio_dma_platform;
+	card.name = "Efika";
+	card.dai_link = efika_fabric_dai;
+	card.num_links = ARRAY_SIZE(efika_fabric_dai);
 
-#else
-#define efika_stac9766_suspend NULL
-#define efika_stac9766_resume  NULL
-#endif
-
-static struct platform_driver efika_fabric = {
-	.probe	= efika_stac9766_probe,
-	.suspend = efika_stac9766_suspend,
- 	.resume = efika_stac9766_resume,
-	.driver	= {
-		.name	= "efika-audio-fabric",
-	},
-};
+	device.card = &card;
+	device.codec_dev = &soc_codec_dev_stac9766;
 
-static __init int efika_fabric_init(void)
-{
-	return platform_driver_register(&efika_fabric);
+	pdev = platform_device_alloc("soc-audio", 1);
+	if (!pdev) {
+		pr_err("efika_fabric_init: platform_device_alloc() failed\n");
+		return -ENODEV;
+	}
+
+	platform_set_drvdata(pdev, &device);
+	device.dev = &pdev->dev;
+
+	rc = platform_device_add(pdev);
+	if (rc) {
+		pr_err("efika_fabric_init: platform_device_add() failed\n");
+		return -ENODEV;
+	}
+	return 0;
 }
 
 static __exit void efika_fabric_exit(void)
diff --git a/sound/soc/fsl/mpc5200_dma.c b/sound/soc/fsl/mpc5200_dma.c
index 220c01f..cc080bb 100644
--- a/sound/soc/fsl/mpc5200_dma.c
+++ b/sound/soc/fsl/mpc5200_dma.c
@@ -299,6 +299,7 @@ static int psc_dma_open(struct snd_pcm_substream *substream)
 		s = &psc_dma->capture;
 	else
 		s = &psc_dma->playback;
+	printk("1\n");
 
 	snd_soc_set_runtime_hwparams(substream, &psc_dma_hardware);
 
@@ -309,11 +310,6 @@ static int psc_dma_open(struct snd_pcm_substream *substream)
 		return rc;
 	}
 
-	if (!psc_dma->playback.active &&
-	    !psc_dma->capture.active) {
-		/* Setup the IRQs */
-	}
-
 	s->stream = substream;
 	return 0;
 }
@@ -521,21 +517,15 @@ static DEVICE_ATTR(capture_overrun, 0644, psc_dma_stat_show,
 			psc_dma_stat_store);
 
 
-int mpc5200_audio_dma_create(struct of_device *op, struct snd_soc_dai *template, int tsize)
+int mpc5200_audio_dma_create(struct of_device *op)
 {
 	phys_addr_t fifo;
 	struct psc_dma *psc_dma;
 	struct resource res;
-	int i, nDAI, size, psc_id, irq, rc;
+	int size, irq, rc;
 	const __be32 *prop;
 	void __iomem *regs;
 
-	/* Get the PSC ID */
-	prop = of_get_property(op->node, "cell-index", &size);
-	if (!prop || size < sizeof *prop)
-		return -ENODEV;
-	psc_id = be32_to_cpu(*prop);
-
 	/* Fetch the registers and IRQ of the PSC */
 	irq = irq_of_parse_and_map(op->node, 0);
 	if (of_address_to_resource(op->node, 0, &res)) {
@@ -555,32 +545,28 @@ int mpc5200_audio_dma_create(struct of_device *op, struct snd_soc_dai *template,
 		return -ENOMEM;
 	}
 
+	/* Get the PSC ID */
+	prop = of_get_property(op->node, "cell-index", &size);
+	if (!prop || size < sizeof *prop)
+		return -ENODEV;
+
 	spin_lock_init(&psc_dma->lock);
+	psc_dma->id = be32_to_cpu(*prop);
 	psc_dma->irq = irq;
 	psc_dma->psc_regs = regs;
 	psc_dma->fifo_regs = regs + sizeof *psc_dma->psc_regs;
 	psc_dma->dev = &op->dev;
 	psc_dma->playback.psc_dma = psc_dma;
 	psc_dma->capture.psc_dma = psc_dma;
-	snprintf(psc_dma->name, sizeof psc_dma->name, "PSC%u", psc_id+1);
-
-	/* Fill out the CPU DAI structure */
-	nDAI = min(tsize, SOC_OF_SIMPLE_MAX_DAI);
-	for (i = 0; i < nDAI; i++) {
-		memcpy(&psc_dma->dai[i], &template[i], sizeof(struct snd_soc_dai));
-		psc_dma->dai[i].private_data = psc_dma;
-		snprintf(psc_dma->stream_name[i], PSC_STREAM_NAME_LEN, template[i].name, psc_dma->name);
-		psc_dma->dai[i].name = psc_dma->stream_name[i];
-		psc_dma->dai[i].id = psc_id;
-	}
+	snprintf(psc_dma->name, sizeof psc_dma->name, "PSC%u", psc_dma->id);
 
 	/* Find the address of the fifo data registers and setup the
 	 * DMA tasks */
 	fifo = res.start + offsetof(struct mpc52xx_psc, buffer.buffer_32);
 	psc_dma->capture.bcom_task =
-		bcom_psc_gen_bd_rx_init(psc_id, 10, fifo, 512);
+		bcom_psc_gen_bd_rx_init(psc_dma->id, 10, fifo, 512);
 	psc_dma->playback.bcom_task =
-		bcom_psc_gen_bd_tx_init(psc_id, 10, fifo);
+		bcom_psc_gen_bd_tx_init(psc_dma->id, 10, fifo);
 	if (!psc_dma->capture.bcom_task ||
 	    !psc_dma->playback.bcom_task) {
 		dev_err(&op->dev, "Could not allocate bestcomm tasks\n");
@@ -642,15 +628,6 @@ int mpc5200_audio_dma_create(struct of_device *op, struct snd_soc_dai *template,
 	if (rc)
 		dev_info(psc_dma->dev, "error creating sysfs files\n");
 
-	rc = snd_soc_register_dais(psc_dma->dai, nDAI);
-	if (rc != 0) {
-		pr_err("Failed to register DAI\n");
-		return 0;
-	}
-
-	/* Tell the ASoC OF helpers about it */
-	of_snd_soc_register_cpu_dai(op->node, psc_dma->dai, nDAI);
-
 	return 0;
 }
 EXPORT_SYMBOL_GPL(mpc5200_audio_dma_create);
@@ -681,7 +658,6 @@ EXPORT_SYMBOL_GPL(mpc5200_audio_dma_destroy);
 static int __init mpc5200_soc_platform_init(void)
 {
 	/* Tell the ASoC OF helpers about it */
-	of_snd_soc_register_platform(&mpc5200_audio_dma_platform);
 	return snd_soc_register_platform(&mpc5200_audio_dma_platform);
 }
 module_init(mpc5200_soc_platform_init);
diff --git a/sound/soc/fsl/mpc5200_dma.h b/sound/soc/fsl/mpc5200_dma.h
index d71e503..d3ecba6 100644
--- a/sound/soc/fsl/mpc5200_dma.h
+++ b/sound/soc/fsl/mpc5200_dma.h
@@ -56,12 +56,11 @@ struct psc_dma {
 	struct mpc52xx_psc_fifo __iomem *fifo_regs;
 	unsigned int irq;
 	struct device *dev;
-	struct snd_soc_dai dai[SOC_OF_SIMPLE_MAX_DAI];
-	char stream_name[SOC_OF_SIMPLE_MAX_DAI][PSC_STREAM_NAME_LEN];
 	spinlock_t lock;
 	u32 sicr;
 	uint sysclk;
 	int imr;
+	int id;
 	unsigned int slots;
 
 	/* per-stream data */
@@ -75,7 +74,7 @@ struct psc_dma {
 	} stats;
 };
 
-int mpc5200_audio_dma_create(struct of_device *op, struct snd_soc_dai *template, int tsize);
+int mpc5200_audio_dma_create(struct of_device *op);
 int mpc5200_audio_dma_destroy(struct of_device *op);
 
 extern struct snd_soc_platform mpc5200_audio_dma_platform;
diff --git a/sound/soc/fsl/mpc5200_psc_ac97.c b/sound/soc/fsl/mpc5200_psc_ac97.c
index 6230c09..39af12d 100644
--- a/sound/soc/fsl/mpc5200_psc_ac97.c
+++ b/sound/soc/fsl/mpc5200_psc_ac97.c
@@ -40,9 +40,11 @@ MODULE_LICENSE("GPL");
 
 #define DRV_NAME "mpc5200-psc-ac97"
 
+/* ALSA only supports a single AC97 device so static is recommend here */
+static struct psc_dma *psc_dma;
+
 static unsigned short psc_ac97_read(struct snd_ac97 *ac97, unsigned short reg)
 {
-	struct psc_dma *psc_dma = ac97->private_data;
 	int timeout;
 	unsigned int val;
 
@@ -87,7 +89,6 @@ static unsigned short psc_ac97_read(struct snd_ac97 *ac97, unsigned short reg)
 
 static void psc_ac97_write(struct snd_ac97 *ac97, unsigned short reg, unsigned short val)
 {
-	struct psc_dma *psc_dma = ac97->private_data;
 	int timeout;
 
 	spin_lock(&psc_dma->lock);
@@ -111,7 +112,6 @@ static void psc_ac97_write(struct snd_ac97 *ac97, unsigned short reg, unsigned s
 
 static void psc_ac97_cold_reset(struct snd_ac97 *ac97)
 {
-	struct psc_dma *psc_dma = ac97->private_data;
 	struct mpc52xx_psc __iomem *regs = psc_dma->psc_regs;
 
 	/* Do a cold reset */
@@ -126,7 +126,6 @@ static void psc_ac97_cold_reset(struct snd_ac97 *ac97)
 
 static void psc_ac97_warm_reset(struct snd_ac97 *ac97)
 {
-	struct psc_dma *psc_dma = ac97->private_data;
 	struct mpc52xx_psc __iomem *regs = psc_dma->psc_regs;
 
 	out_be32(&regs->sicr, psc_dma->sicr | MPC52xx_PSC_SICR_AWR);
@@ -245,6 +244,7 @@ static int psc_ac97_trigger(struct snd_pcm_substream *substream, int cmd,
 static int psc_ac97_set_fmt(struct snd_soc_dai *cpu_dai, unsigned int format)
 {
 	struct psc_dma *psc_dma = cpu_dai->private_data;
+
 	dev_dbg(psc_dma->dev, "psc_ac97_set_fmt(cpu_dai=%p, format=%i)\n",
 				cpu_dai, format);
 
@@ -272,9 +272,9 @@ static struct snd_soc_dai_ops psc_ac97_digital_ops = {
 	.set_fmt	= psc_ac97_set_fmt,
 };
 
-static struct snd_soc_dai psc_ac97_dai_template[] = {
+struct snd_soc_dai psc_ac97_dai[] = {
 {
-	.name   = "%s AC97",
+	.name   = "AC97",
 	.suspend = psc_ac97_suspend,
 	.resume = psc_ac97_resume,
 	.playback = {
@@ -292,7 +292,7 @@ static struct snd_soc_dai psc_ac97_dai_template[] = {
 	.ops = &psc_ac97_analog_ops,
 },
 {
-	.name   = "%s AC97",
+	.name   = "SPDIF",
 	.playback = {
 		.channels_min   = 1,
 		.channels_max   = 2,
@@ -302,6 +302,8 @@ static struct snd_soc_dai psc_ac97_dai_template[] = {
 	},
 	.ops = &psc_ac97_digital_ops,
 }};
+EXPORT_SYMBOL_GPL(psc_ac97_dai);
+
 
 
 /* ---------------------------------------------------------------------
@@ -312,19 +314,27 @@ static struct snd_soc_dai psc_ac97_dai_template[] = {
 static int __devinit psc_ac97_of_probe(struct of_device *op,
 				      const struct of_device_id *match)
 {
-	int rc, id1, id2, timeout, max_reset;
-	struct psc_dma *psc_dma;
+	int rc, i, id1, id2, timeout, max_reset;
 	struct snd_ac97 ac97;
 	struct mpc52xx_psc __iomem *regs;
 
-	rc = mpc5200_audio_dma_create(op, psc_ac97_dai_template, ARRAY_SIZE(psc_ac97_dai_template));
+	rc = mpc5200_audio_dma_create(op);
 	if (rc != 0)
 		return rc;
 
+	rc = snd_soc_register_dais(psc_ac97_dai, ARRAY_SIZE(psc_ac97_dai));
+	if (rc != 0) {
+		pr_err("Failed to register DAI\n");
+		return 0;
+	}
+
 	psc_dma = dev_get_drvdata(&op->dev);
 	regs = psc_dma->psc_regs;
 	ac97.private_data = psc_dma;
 
+	for (i = 0; i < ARRAY_SIZE(psc_ac97_dai); i++)
+		psc_ac97_dai[i].private_data = psc_dma;
+
 	psc_dma->imr = 0;
 	out_be16(&psc_dma->psc_regs->isr_imr.imr, psc_dma->imr);
 
diff --git a/sound/soc/fsl/mpc5200_psc_ac97.h b/sound/soc/fsl/mpc5200_psc_ac97.h
index d028c55..4bc18c3 100644
--- a/sound/soc/fsl/mpc5200_psc_ac97.h
+++ b/sound/soc/fsl/mpc5200_psc_ac97.h
@@ -7,7 +7,9 @@
 #ifndef __SOUND_SOC_FSL_MPC52xx_PSC_AC97_H__
 #define __SOUND_SOC_FSL_MPC52xx_PSC_AC97_H__
 
-#define MPC5200_AC97_ANALOG 0
-#define MPC5200_AC97_DIGITAL 1
+extern struct snd_soc_dai psc_ac97_dai[];
+
+#define MPC5200_AC97_NORMAL 0
+#define MPC5200_AC97_SPDIF 1
 
 #endif /* __SOUND_SOC_FSL_MPC52xx_PSC_AC97_H__ */
diff --git a/sound/soc/fsl/mpc5200_psc_i2s.c b/sound/soc/fsl/mpc5200_psc_i2s.c
index da988ef..35dbb18 100644
--- a/sound/soc/fsl/mpc5200_psc_i2s.c
+++ b/sound/soc/fsl/mpc5200_psc_i2s.c
@@ -149,7 +149,7 @@ static int psc_i2s_set_sysclk(struct snd_soc_dai *cpu_dai,
 			dev_dbg(psc_dma->dev, "psc_i2s_set_sysclk(clkdiv %d freq error=%ldHz)\n",
 					clkdiv, (ppc_proc_freq / clkdiv - freq));
 
-			return mpc52xx_set_psc_clkdiv(psc_dma->dai[0].id + 1, clkdiv);
+			return mpc52xx_set_psc_clkdiv(psc_dma->id + 1, clkdiv);
 		}
 	}
 	return 0;
@@ -190,8 +190,8 @@ static struct snd_soc_dai_ops psc_i2s_dai_ops = {
 	.set_fmt	= psc_i2s_set_fmt,
 };
 
-static struct snd_soc_dai psc_i2s_dai_template = {
-	.name   = "%s I2S",
+static struct snd_soc_dai psc_i2s_dai[] = {{
+	.name   = "I2S",
 	.playback = {
 		.channels_min = 2,
 		.channels_max = 2,
@@ -205,7 +205,7 @@ static struct snd_soc_dai psc_i2s_dai_template = {
 		.formats = PSC_I2S_FORMATS,
 	},
 	.ops = &psc_i2s_dai_ops,
-};
+}};
 
 /* ---------------------------------------------------------------------
  * OF platform bus binding code:
@@ -218,10 +218,16 @@ static int __devinit psc_i2s_of_probe(struct of_device *op,
 	int rc;
 	struct psc_dma *psc_dma;
 
-	rc = mpc5200_audio_dma_create(op, &psc_i2s_dai_template, 1);
+	rc = mpc5200_audio_dma_create(op);
 	if (rc != 0)
 		return rc;
 
+	rc = snd_soc_register_dais(psc_i2s_dai, ARRAY_SIZE(psc_i2s_dai));
+	if (rc != 0) {
+		pr_err("Failed to register DAI\n");
+		return 0;
+	}
+
 	psc_dma = dev_get_drvdata(&op->dev);
 
 	/* Configure the serial interface mode; defaulting to CODEC8 mode */
diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index bad9d88..cc1e618 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -20,6 +20,8 @@
  *   o Support TDM on PCM and I2S
  */
 
+#define DEBUG
+
 #include <linux/module.h>
 #include <linux/moduleparam.h>
 #include <linux/init.h>
@@ -125,7 +127,7 @@ static int soc_pcm_apply_symmetry(struct snd_pcm_substream *substream)
 
 	if (codec_dai->symmetric_rates || cpu_dai->symmetric_rates ||
 	    machine->symmetric_rates) {
-		dev_dbg(card->dev, "Symmetry forces %dHz rate\n", 
+		dev_dbg(card->dev, "Symmetry forces %dHz rate\n",
 			machine->rate);
 
 		ret = snd_pcm_hw_constraint_minmax(substream->runtime,
diff --git a/sound/soc/soc-dapm.c b/sound/soc/soc-dapm.c
index c1222fa..f3ccbd0 100644
--- a/sound/soc/soc-dapm.c
+++ b/sound/soc/soc-dapm.c
@@ -29,6 +29,8 @@
  *    o Support for reduced codec bias currents.
  */
 
+#define DEBUG
+
 #include <linux/module.h>
 #include <linux/moduleparam.h>
 #include <linux/init.h>
